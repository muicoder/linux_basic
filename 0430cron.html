<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="包括了 crontab 与 at 这两支程序啦！">
	<title>鸟哥的 Linux 私房菜 -- 第十五章、例行性工作调度(crontab)</title>
	<style type="text/css">
	</style>
	<link href="./vbird_files/style_2013.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- 正中央的 1000 像素的内容 -->
<div class="tablearea">
<div class="mainarea">
<div class="block1">
<!-- 本文的档头部分 -->
<h1>第十五章、例行性工作调度(crontab)</h1>
<div style="text-align:right">
	<span class="text_history">最近更新日期：2015/07/31</span>
</div>
<!-- 本文的档头部分 -->
<div class="abstract">
	<p>学习了基础篇也一阵子了，你会发现到为什么系统常常会主动的进行一些任务？这些任务到底是谁在设置工作的？
	如果你想要让自己设计的备份程序可以自动的在系统底下运行，而不需要手动来启动他，又该如何处置？
	这些例行的工作可能又分为『单一』工作与『循环』工作，在系统内又是哪些服务在负责？
	还有还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，可以办的到吗？
	嘿嘿！这些种种要如何处理，就看看这一章先！</p>
</div>
<!-- 本文的链接区部分 -->
<div class="links">
<ul>
	<li><a href="0430cron.html#whatiscron">15.1 什么是例行性工作调度</a>
	<ul>
		<li><a href="0430cron.html#whatiscron_type">15.1.1 Linux 工作调度的种类： at, crontab</a></li>
		<li><a href="0430cron.html#whatiscron_linux">15.1.2 CentOS Linux 系统上常见的例行性工作</a></li>
	</ul></li>
	<li><a href="0430cron.html#atjob">15.2 仅运行一次的工作调度</a>
	<ul>
		<li><a href="0430cron.html#atjob_how">15.2.1 atd 的启动与 at 运作的方式</a>： <a href="0430cron.html#at_deny">/etc/at.deny</a></li>
		<li><a href="0430cron.html#atjob_work">15.2.2 实际运作单一工作调度</a>： <a href="0430cron.html#at">at</a>,
			<a href="0430cron.html#atq_atrm">atq &amp; atrm</a>, <a href="0430cron.html#batch">batch</a></li>
	</ul></li>
	<li><a href="0430cron.html#cron">15.3 循环运行的例行性工作调度</a>
	<ul>
		<li><a href="0430cron.html#crontab_user">15.3.1 用户的设置</a>： <a href="0430cron.html#cron_deny">/etc/cron.deny</a>, <a href="0430cron.html#crontab">crontab</a></li>
		<li><a href="0430cron.html#etc_crontab1">15.3.2 系统的设置档</a>： <a href="0430cron.html#etc_crontab">/etc/crontab, /etc/cron.d/*</a></li>
		<li><a href="0430cron.html#security">15.3.3 一些注意事项</a></li>
	</ul></li>
	<li><a href="0430cron.html#anacron_1">15.4 可唤醒停机期间的工作任务</a>
	<ul>
		<li><a href="0430cron.html#anacron_what">15.4.1 什么是 anacron</a></li>
		<li><a href="0430cron.html#anacron">15.4.2 anacron 与 /etc/anacrontab</a></li>
	</ul></li>
	<li><a href="0430cron.html#hint">15.5 重点回顾</a></li>
	<li><a href="0430cron.html#ex">15.6 本章习题</a></li>
</ul>
</div>
</div>
<!-- 本文的正式部分 -->
<a id="whatiscron"></a>
<div class="block1">
<h2>15.1 什么是例行性工作调度</h2>
	<p>每个人或多或少都有一些约会或者是工作，<span class="text_import2">有的工作是例行性的</span>，
	例如每年一次的加薪、每个月一次的工作报告、每周一次的午餐会报、每天需要的打卡等等；
	<span class="text_import2">有的工作则是临时发生的</span>，例如刚好总公司有高官来访，需要你准备演讲器材等等！
	用在生活上面，例如每年的爱人的生日、每天的起床时间等等、还有突发性的 3C 用品大降价 (啊！真希望天天都有！) 
	等等啰。</p>
	<p>像上面这些例行性工作，通常你得要记录在行事历上面才能避免忘记！不过，由于我们常常在电脑前面的缘故，
	如果电脑系统能够主动的通知我们的话，那么不就轻松多了！嘿嘿！这个时候 Linux 的例行性工作调度就可以派上场了！
	在不考虑硬件与我们服务器的链接状态下，我们的 Linux 可以帮你提醒很多任务，例如：每一天早上 
	8:00 钟要服务器连接上音响，并启动音乐来唤你起床；而中午
	12:00 希望 Linux 可以发一封信到你的邮件信箱，提醒你可以去吃午餐了；
	另外，在每年的你爱人生日的前一天，先发封信提醒你，以免忘记这么重要的一天。</p>
	<p>那么 Linux 的例行性工作是如何进行调度的呢？所谓的调度就是将这些工作安排运行的流程之意！
	咱们的 Linux 调度就是透过 crontab 与 at 这两个东西！这两个玩意儿有啥异同？就让我们来瞧瞧先！</p>
	<a id="whatiscron_type"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.1.1 Linux 工作调度的种类： at, cron</h2>
		<p>从上面的说明当中，我们可以很清楚的发现两种工作调度的方式：</p>
		<ul>
		<li>一种是例行性的，就是每隔一定的周期要来办的事项；</li>
		<li>一种是突发性的，就是这次做完以后就没有的那一种 ( 3C 大降价...)</li>
		</ul>
		<p>那么在 Linux 底下如何达到这两个功能呢？那就得使用 at 与 crontab 这两个好东西啰！</p>
		<ul>
		<li><span class="text_import1">at</span> ：at 是个可以处理仅运行一次就结束调度的指令，不过要运行 at 时，
		必须要有 atd 这个<a href="0560daemons.html">服务 (第十七章)</a> 的支持才行。在某些新版的 distributions 
		中，atd 可能缺省并没有启动，那么 at 这个指令就会失效呢！不过我们的 CentOS 缺省是启动的！<br><br></li>
		<li><span class="text_import1">crontab</span> ：crontab 这个指令所设置的工作将会循环的一直进行下去！
		可循环的时间为分钟、小时、每周、每月或每年等。crontab 除了可以使用指令运行外，亦可编辑 /etc/crontab 来支持。
		至于让 crontab 可以生效的服务则是 crond 这个服务喔！</li>
		</ul>
		<p>底下我们先来谈一谈 Linux 的系统到底在做什么事情，怎么有若干多的工作调度在进行呢？然后再回来谈一谈
		at 与 crontab 这两个好东西！</p>
	<br></div><br>
	<a id="whatiscron_linux"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.1.2 CentOS Linux 系统上常见的例行性工作</h2>
		<p>如果你曾经使用过 Linux 一阵子了，那么你大概会发现到 Linux 会主动的帮我们进行一些工作呢！
		比方说自动的进行在线更新 (on-line update)、自动的进行 updatedb (<a href="0220filemanager.html#locate">第六章谈到的 locate 指令</a>) 更新文件名数据库、自动的作注册表分析
		(所以 root 常常会收到标题为 logwatch 的信件) 等等。这是由于系统要正常运作的话，
		某些在背景底下的工作必须要定时进行的缘故。基本上 Linux 系统常见的例行性任务有：</p>
		<ul style="padding-left: 25px">
		<li><span class="text_import2">进行注册表的轮替 (log rotate)</span>：<br>
		Linux 会主动的将系统所发生的各种信息都记录下来，这就是<a href="0570syslog.html">注册表 (第十八章)</a>。
		由于系统会一直记录登录信息，所以注册表将会越来越大！我们知道大型文件不但占容量还会造成读写性能的困扰，
		因此适时的将注册表数据挪一挪，让旧的数据与新的数据分别存放，则比较可以有效的记录登录信息。这就是 log rotate 
		的任务！这也是系统必要的例行任务；<br><br></li>
		<li><span class="text_import2">注册表分析 logwatch 的任务</span>：<br>
		如果系统发生了软件问题、硬件错误、资安问题等，绝大部分的错误信息都会被记录到注册表中，
		因此系统管理员的重要任务之一就是分析注册表。但你不可能手动透过 vim 等软件去查看注册表，因为数据太复杂了！
		我们的 CentOS 提供了一只程序『 logwatch 』来主动分析登录信息，所以你会发现，你的 root 老是会收到标题为 logwatch
		的信件，那是正常的！你最好也能够看看该信件的内容喔！<br><br></li>
		<li><span class="text_import2">创建 locate 的数据库</span>：<br>
		在第六章我们谈到的 <a href="0220filemanager.html#locate">locate</a> 指令时，
		我们知道该指令是透过已经存在的文件名数据库来进行系统上文件名的查找。我们的文件名数据库是放置到 /var/lib/mlocate/ 中。
		问题是，这个数据库怎么会自动更新啊？嘿嘿！这就是系统的例行性工作所产生的效果啦！系统会主动的进行
		updatedb 喔！<br><br></li>
		<li><span class="text_import2">man page 查找数据库的创建</span>：<br>
		与 locate 数据库类似的，可提供快速查找的 man page db 也是个数据库，但如果要使用 man page 数据库时，就得要运行 mandb 才能够创建好啊！
		而这个 man page 数据库也是透过系统的例行性工作调度来自动运行的哩！<br><br></li>
		<li><span class="text_import2">RPM 软件注册表的创建</span>：<br>
		RPM (<a href="0520rpm_and_srpm.html">第二十二章</a>) 是一种软件管理的机制。由于系统可能会常常变更软件，
		包括软件的新安装、非经常性更新等，都会造成软件文件名的差异。为了方便未来追踪，系统也帮我们将文件名作个排序的记录呢！
		有时候系统也会透过调度来帮忙 RPM 数据库的重新建置喔！<br><br></li>
		<li><span class="text_import2">移除暂存盘</span>：<br>
		某些软件在运作中会产生一些暂存盘，但是当这个软件关闭时，这些暂存盘可能并不会主动的被移除。
		有些暂存盘则有时间性，如果超过一段时间后，这个暂存盘就没有效用了，此时移除这些暂存盘就是一件重要的工作！
		否则磁盘容量会被耗光。系统透过例行性工作调度运行名为 tmpwatch 的指令来删除这些暂存盘呢！<br><br></li>
		<li><span class="text_import2">与网络服务有关的分析行为</span>：<br>
		如果你有安装类似 WWW 服务器软件 (一个名为 apache 的软件)，那么你的 Linux 系统通常就会主动的分析该软件的注册表。
		同时某些凭证与认证的网络信息是否过期的问题，我们的 Linux 系统也会很亲和的帮你进行自动检查！</li>
		</ul>
		<p>其实你的系统会进行的例行性工作与你安装的软件多寡有关，如果你安装过多的软件，某些服务功能的软件都会附上分析工具，
		那么你的系统就会多出一些例行性工作啰！像鸟哥的主机还多加了很多自己撰写的分析工具，以及其他第三方协力软件的分析软件，
		嘿嘿！俺的 Linux 工作量可是非常大的哩！因为有这么多的工作需要进行，所以我们当然得要了解例行性工作的处理方式啰！</p>
	<br></div><br>
</div>
<a id="atjob"></a>
<div class="block1">
<h2>15.2 仅运行一次的工作调度</h2>
	<p>首先，我们先来谈谈单一工作调度的运作，那就是 at 这个指令的运作！</p>
	<a id="atjob_how"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.2.1 atd 的启动与 at 运作的方式</h2>
		<p>要使用单一工作调度时，我们的 Linux 系统上面必须要有负责这个调度的服务，那就是 atd 这个玩意儿。
		不过并非所有的 Linux distributions 都缺省会把他打开的，所以呢，某些时刻我们必须要手动将他启用才行。
		启用的方法很简单，就是这样：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">systemctl restart atd</span>  <span class="term_note"># 重新启动 atd 这个服务</span>
[root@study ~]# <span class="term_command">systemctl enable atd </span>  <span class="term_note"># 让这个服务开机就自动启动</span>
[root@study ~]# <span class="term_command">systemctl status atd </span>  <span class="term_note"># 查阅一下 atd 目前的状态</span>
atd.service - Job spooling tools
   Loaded: loaded (/usr/lib/systemd/system/atd.service; <span class="term_write">enabled</span>)       <span class="term_note"># 是否开机启动</span>
   Active: <span class="term_write">active (running)</span> since Thu 2015-07-30 19:21:21 CST; 23s ago <span class="term_note"># 是否正在运作中</span>
 Main PID: 26503 (atd)
   CGroup: /system.slice/atd.service
           └─26503 /usr/sbin/atd -f
Jul 30 19:21:21 study.centos.vbird systemd[1]: Starting Job spooling tools...
Jul 30 19:21:21 study.centos.vbird systemd[1]: Started Job spooling tools.
</pre></td></tr></tbody></table>
		<p>重点就是要看到上表中的特殊字体，包括『 enabled 』以及『 running 』时，这才是 atd 真的有在运作的意思喔！这部份我们在<a href="0560daemons.html">第十七章</a>会谈及。</p>
		<ul class="toplist"><li>at 的运作方式</li></ul>
		<p>既然是工作调度，那么应该会有产生工作的方式，并且将这些工作排进行程表中啰！OK！那么产生工作的方式是怎么进行的？
		事实上，<span class="text_import2">我们使用 at 这个指令来产生所要运作的工作，并将这个工作以文本档的方式写入
		/var/spool/at/ 目录内，该工作便能等待 atd 这个服务的取用与运行了</span>。就这么简单。</p>
		<p>不过，并不是所有的人都可以进行 at 工作调度喔！为什么？因为安全的理由啊～
		很多主机被所谓的『绑架』后，最常发现的就是他们的系统当中多了很多的怪客程序 (cracker program)，
		这些程序非常可能运用工作调度来运行或搜集系统信息，并定时的回报给怪客团体！
		所以啰，除非是你认可的帐号，否则先不要让他们使用 at 吧！那怎么达到使用 at 的列管呢？</p>
		<a id="at_deny"></a>
		<p>我们可以利用 /etc/at.allow 与 /etc/at.deny 这两个文件来进行 at 的使用限制呢！
		加上这两个文件后， at 的工作情况其实是这样的：</p>
		<ol class="text_import2">
		<li>先找寻 <strong>/etc/at.allow</strong> 这个文件，写在这个文件中的用户才能使用 at
		，没有在这个文件中的用户则不能使用 at (即使没有写在 at.deny 当中)；<br><br></li>
		<li>如果 /etc/at.allow 不存在，就寻找<strong> /etc/at.deny</strong> 这个文件，若写在这个
		at.deny 的用户则不能使用 at ，而没有在这个 at.deny 文件中的用户，就可以使用
		at 咯；<br><br></li>
		<li>如果两个文件都不存在，那么只有 root 可以使用 at 这个指令。</li>
		</ol>
		<p>透过这个说明，我们知道 /etc/at.allow 是管理较为严格的方式，而 /etc/at.deny 则较为松散 
		(因为帐号没有在该文件中，就能够运行 at 了)。在一般的 distributions 当中，由于假设系统上的所有用户都是可信任的，
		因此系统通常会保留一个空的 /etc/at.deny 文件，意思是允许所有人使用 at 指令的意思 (您可以自行检查一下该文件)。
		不过，万一你不希望有某些用户使用 at 的话，将那个用户的帐号写入 /etc/at.deny 即可！
		一个帐号写一行。</p>
	<br></div><br>
	<a id="atjob_work"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.2.2 实际运作单一工作调度</h2>
		<a id="at"></a>
		<p>单一工作调度的进行就使用 at 这个指令啰！这个指令的运作非常简单！将 at 加上一个时间即可！基本的语法如下：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">at [-mldv] TIME</span>
[root@study ~]# <span class="term_command">at -c 工作号码</span>
<span class="term_say">选项与参数：
-m  ：当 at 的工作完成后，即使没有输出消息，亦以 email 通知用户该工作已完成。
-l  ：at -l 相当于 atq，列出目前系统上面的所有该用户的 at 调度；
-d  ：at -d 相当于 atrm ，可以取消一个在 at 调度中的工作；
-v  ：可以使用较明显的时间格式列出 at 调度中的任务栏表；
-c  ：可以列出后面接的该项工作的实际指令内容。
TIME：时间格式，这里可以定义出『什么时候要进行 at 这项工作』的时间，格式有：
  HH:MM				ex&gt; 04:00
	在今日的 HH:MM 时刻进行，若该时刻已超过，则明天的 HH:MM 进行此工作。
  HH:MM YYYY-MM-DD		ex&gt; 04:00 2015-07-30
	强制规定在某年某月的某一天的特殊时刻进行该工作！
  HH:MM[am|pm] [Month] [Date]	ex&gt; 04pm July 30
	也是一样，强制在某年某月某日的某时刻进行！
  HH:MM[am|pm] + number [minutes|hours|days|weeks]
	ex&gt; now + 5 minutes	ex&gt; 04pm + 3 days
	就是说，在某个时间点『再加几个时间后』才进行。</span>
</pre></td></tr></tbody></table>
		<p>老实说，这个 at 指令的下达最重要的地方在于『时间』的指定了！鸟哥喜欢使用『 now + ... 』
		的方式来定义现在过多少时间再进行工作，但有时也需要定义特定的时间点来进行！底下的范例先看看啰！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：再过五分钟后，将 /root/.bashrc 寄给 root 自己</span>
[root@study ~]# <span class="term_command">at now + 5 minutes</span>  <span class="term_note">&lt;==记得单位要加 s 喔！</span>
at&gt; <span class="term_command">/bin/mail -s "testing at job" root &lt; /root/.bashrc</span>
at&gt; &lt;EOT&gt;   <span class="term_note">&lt;==这里输入 [ctrl] + d 就会出现 &lt;EOF&gt; 的字样！代表结束！</span>
job 2 at Thu Jul 30 19:35:00 2015
<span class="term_say"># 上面这行信息在说明，第 2 个 at 工作将在 2015/07/30 的 19:35 进行！
# 而运行 at 会进入所谓的 at shell 环境，让你下达多重指令等待运作！</span>
<span class="term_hd">范例二：将上述的第 2 项工作内容列出来查阅</span>
[root@study ~]# <span class="term_command">at -c 2</span>
#!/bin/sh               <span class="term_note">&lt;==就是透过 bash shell 的啦！</span>
# atrun uid=0 gid=0
# mail root 0
umask 22
<span class="term_say">....(中间省略许多的环境变量项目)....</span>
cd /etc/cron\.d || {
         echo 'Execution directory inaccessible' &gt;&amp;2
         exit 1
}
<span class="term_write">${SHELL:-/bin/sh} &lt;&lt; 'marcinDELIMITER410efc26'
/bin/mail -s "testing at job" root &lt; /root/.bashrc    <span class="term_note"># 这一行最重要！</span>
marcinDELIMITER410efc26</span>
<span class="term_say"># 你可以看到指令运行的目录 (/root)，还有多个环境变量与实际的指令内容啦！</span>
<span class="term_hd">范例三：由于机房预计于 2015/08/05 停电，我想要在 2015/08/04 23:00 关机？</span>
[root@study ~]# <span class="term_command">at 23:00 2015-08-04</span>
at&gt; <span class="term_write">/bin/sync</span>
at&gt; <span class="term_write">/bin/sync</span>
at&gt; <span class="term_write">/sbin/shutdown -h now</span>
at&gt; &lt;EOT&gt;
job 3 at Tue Aug  4 23:00:00 2015
<span class="term_say"># 您瞧瞧！ at 还可以在一个工作内输入多个指令呢！不错吧！</span>
</pre></td></tr></tbody></table>
		<p>事实上，当我们使用 at 时会进入一个 at shell 的环境来让用户下达工作指令，此时，<span class="text_import2">建议你最好使用绝对路径来下达你的指令，比较不会有问题喔</span>！由于指令的下达与 PATH 变量有关，
		同时与当时的工作目录也有关连 (如果有牵涉到文件的话)，因此使用绝对路径来下达指令，会是比较一劳永逸的方法。
		为什么呢？举例来说，你在 /tmp 下达『 at now 』然后输入『 mail -s "test" root &lt; .bashrc 』，
		问一下，那个 .bashrc 的文件会是在哪里？答案是『 /tmp/.bashrc 』！因为<span class="text_import2">
		at 在运作时，会跑到当时下达 at 指令的那个工作目录</span>的缘故啊！</p>
		<p>有些朋友会希望『我要在某某时刻，在我的终端机显示出 Hello 的字样』，然后就在 at 里面下达这样的信息『
		echo "Hello" 』。等到时间到了，却发现没有任何消息在屏幕上显示，这是啥原因啊？<span class="text_import2">这是因为 at 的运行与终端机环境无关，而所有 standard output/standard error output
		都会发送到运行者的 mailbox 去</span>啦！所以在终端机当然看不到任何信息。那怎办？没关系，
		可以透过终端机的设备来处理！假如你在 tty1 登录，则可以使用『 echo "Hello" &gt; /dev/tty1 』来取代。</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		要注意的是，如果在 at shell 内的指令并没有任何的消息输出，那么 at 缺省不会发 email 给运行者的。
		如果你想要让 at 无论如何都发一封 email 告知你是否运行了指令，那么可以使用『 at -m 时间格式 』来下达指令喔！
		at 就会发送一个消息给运行者，而不论该指令运行有无消息输出了！
		</fieldset><br>
		<p>at 有另外一个很棒的优点，那就是『背景运行』的功能了！什么是背景运行啊？很难了解吗？其实与 bash 的 nohup 
		(<a href="0440processcontrol.html#nohup">第十六章</a>) 类似啦！
		鸟哥提我自己的几个例子来给您听听，您就瞭了！</p>
		<ul>
		<li><span class="text_import2">脱机继续工作的任务</span>：鸟哥初次接触 Unix 为的是要跑空气品质模式，
		那是一种大型的程序，这个程序在当时的硬件底下跑，一个案例要跑 3 天！由于鸟哥也要进行其他研究工作，因此常常使用 Windows
		98 (你没看错！鸟哥是老人...) 来连接到 Unix 工作站跑那个 3 天的案例！结果你也该知道， Windows 98 连开三天而不当机的机率是很低的～@_@～
		而当机时，所有在 Windows 上的连接都会中断！包括鸟哥在跑的那个程序也中断了～呜呜～明明再三个钟头就跑完的程序，
		由于当机害我又得跑 3 天！<br><br></li>
		<li>另一个常用的时刻则是例如上面的范例三，由于某个突发状况导致你必须要进行某项工作时，这个 at 就很好用啦！</li>
		</ul>
		<p><span class="text_import2">由于 at 工作调度的使用上，系统会将该项 at 工作独立出你的 bash 环境中，
		直接交给系统的 atd 程序来接管，因此，当你下达了 at 的工作之后就可以立刻脱机了，
		剩下的工作就完全交给 Linux 管理即可</span>！所以啰，如果有长时间的网络工作时，嘿嘿！
		使用 at 可以让你免除网络断线后的困扰喔！ ^_^</p>
		<a id="atq_atrm"></a>
		<ul class="toplist"><li>at 工作的管理</li></ul>
		<p>那么万一我下达了 at 之后，才发现指令输入错误，该如何是好？就将他移除啊！利用 atq 与 atrm 吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">atq</span>
[root@study ~]# <span class="term_command">atrm (jobnumber)</span>
<span class="term_hd">范例一：查找目前主机上面有多少的 at 工作调度？</span>
[root@study ~]# <span class="term_command">atq</span>
3       Tue Aug  4 23:00:00 2015 a root
<span class="term_say"># 上面说的是：『在 2015/08/04 的 23:00 有一项工作，该项工作指令下达者为 
# root』而且，该项工作的工作号码 (jobnumber) 为 3 号喔！</span>
<span class="term_hd">范例二：将上述的第 3 个工作移除！</span>
[root@study ~]# <span class="term_command">atrm 3</span>
[root@study ~]# <span class="term_command">atq</span>
<span class="term_say"># 没有任何信息，表示该工作被移除了！</span>
</pre></td></tr></tbody></table>
		<p>如此一来，你可以利用 atq 来查找，利用 atrm 来删调试误的指令，利用 at 来直接下达单一工作调度！很简单吧！
		不过，有个问题需要处理一下。<span class="text_import2">如果你是在一个非常忙碌的系统下运作 at ，
		能不能指定你的工作在系统较闲的时候才进行</span>呢？可以的，那就使用 batch 指令吧！</p>
		<a id="batch"></a>
		<ul class="toplist"><li>batch：系统有空时才进行背景任务</li></ul>
		<p>其实 batch 是利用 at 来进行指令的下达啦！只是加入一些控制参数而已。这个 batch 神奇的地方在于：<span class="text_import2">他会在 CPU 的工作负载小于 0.8 的时候，才进行你所下达的工作任务</span>啦！
		那什么是工作负载 0.8 呢？这个工作负载的意思是： CPU 在单一时间点所负责的工作数量。不是 CPU 的使用率喔！
		举例来说，如果我有一只程序他需要一直使用 CPU 的运算功能，那么此时 CPU 的使用率可能到达 100% ，
		但是 CPU 的工作负载则是趋近于『 1 』，因为 CPU 仅负责一个工作嘛！如果同时运行这样的程序两支呢？
		CPU 的使用率还是 100% ，但是工作负载则变成 2 了！了解乎？</p>
		<p>所以也就是说，当 CPU 的工作负载越大，代表 CPU 必须要在不同的工作之间进行频繁的工作切换。
		这样的 CPU 运作情况我们在第零章有谈过，忘记的话请回去瞧瞧！因为一直切换工作，所以会导致系统忙碌啊！
		系统如果很忙碌，还要额外进行 at ，不太合理！所以才有 batch 指令的产生！</p>
		<p>在 CentOS 7 底下的 batch 已经不再支持时间参数了，因此 batch 可以拿来作为判断是否要立刻运行背景程序的依据！
		我们底下来实验一下 batch 好了！为了产生 CPU 较高的工作负载，因此我们用了 12 章里面计算 pi 的脚本，连续运行 4 次这只程序，
		来仿真高负载，然后来玩一玩 batch 的工作现象：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：请运行 pi 的计算，然后在系统闲置时，运行 updatdb 的任务</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a(1)" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a(1)" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a(1)" | bc -lq &amp;</span>
[root@study ~]# <span class="term_command">echo "scale=100000; 4*a(1)" | bc -lq &amp;</span>
<span class="term_say"># 然后等待个大约数十秒的时间，之后再来确认一下工作负载的情况！</span>
[root@study ~]# <span class="term_command">uptime</span>
 19:56:45 up 2 days, 19:54,  2 users,  <span class="term_write">load average: 3.93, 2.23, 0.96</span>
[root@study ~]# <span class="term_command">batch</span>
at&gt; <span class="term_command">/usr/bin/updatedb</span>
at&gt; &lt;EOT&gt;
job 4 at Thu Jul 30 19:57:00 2015
[root@study ~]# <span class="term_command">date;atq</span>
Thu Jul 30 19:57:47 CST 2015
4       Thu Jul 30 19:57:00 2015 b root
<span class="term_say"># 可以看得到，明明时间已经超过了，却没有实际运行 at 的任务！</span>
[root@study ~]# <span class="term_command">jobs</span>
[1]   Running                 echo "scale=100000; 4*a(1)" | bc -lq &amp;
[2]   Running                 echo "scale=100000; 4*a(1)" | bc -lq &amp;
[3]-  Running                 echo "scale=100000; 4*a(1)" | bc -lq &amp;
[4]+  Running                 echo "scale=100000; 4*a(1)" | bc -lq &amp;
[root@study ~]# <span class="term_command">kill -9 %1 %2 %3 %4</span>
<span class="term_say"># 这时先用 jobs 找出背景工作，再使用 kill 删除掉四个背景工作后，慢慢等待工作负载的下降</span>
[root@study ~]# <span class="term_command">uptime; atq</span>
 20:01:33 up 2 days, 19:59,  2 users,  load average: 0.89, 2.29, 1.40
4       Thu Jul 30 19:57:00 2015 b root
[root@study ~]# <span class="term_command">uptime; atq</span>
 20:02:52 up 2 days, 20:01,  2 users,  load average: 0.23, 1.75, 1.28
<span class="term_say"># 在 19:59 时，由于 loading 还是高于 0.8，因此 atq 可以看得到 at job 还是持续再等待当中喔！
# 但是到了 20:01 时， loading 降低到 0.8 以下了，所以 atq 就运行完毕啰！</span>
</pre></td></tr></tbody></table>
		<p>使用 uptime 可以观察到 1, 5, 15 分钟的『平均工作负载』量，因为是平均值，所以当我们如上表删除掉四个工作后，工作负载不会立即降低，
		需要一小段时间让这个 1 分钟平均值慢慢回复到接近 0 啊！当小于 0.8 之后的『整分钟时间』时，atd 就会将 batch 的工作运行掉了！</p>
		<p>什么是『整分钟时间』呢？不论是 at 还是底下要介绍的 crontab，他们最小的时间单位是『分钟』，所以，基本上，他们的工作是『每分钟检查一次』来处理的！
		就是整分 (秒为 0 的时候)，这样了解乎？同时，你会发现其实 batch 也是使用 atq/atrm 来管理的！</p>
	<br></div>
</div>
<a id="cron"></a>
<div class="block1">
<h2>15.3 循环运行的例行性工作调度</h2>
	<p>相对于 at 是仅运行一次的工作，<span class="text_import2">循环运行的例行性工作调度则是由 cron (crond)
	这个系统服务来控制的</span>。刚刚谈过 Linux 系统上面原本就有非常多的例行性工作，因此这个系统服务是缺省启动的。另外，
	由于用户自己也可以进行例行性工作调度，所以啰， Linux 也提供用户控制例行性工作调度的指令 (crontab)。
	底下我们分别来聊一聊啰！</p>
	<a id="crontab_user"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.3.1 用户的设置</h2>
		<a id="cron_deny"></a>
		<p>用户想要创建循环型工作调度时，使用的是 crontab 这个指令啦～不过，为了安全性的问题，
		与 at 同样的，我们可以限制使用 crontab 的用户帐号喔！使用的限制数据有：</p>
		<ul>
		<li><span class="text_import2">/etc/cron.allow</span>：<br>
		将可以使用 crontab 的帐号写入其中，若不在这个文件内的用户则不可使用 crontab；<br><br></li>
		<li><span class="text_import2">/etc/cron.deny</span>：<br>
		将不可以使用 crontab 的帐号写入其中，若未记录到这个文件当中的用户，就可以使用 crontab 。</li></ul>
		<p>与 at 很像吧！同样的，以优先级来说， /etc/cron.allow 比 /etc/cron.deny 要优先，
		而判断上面，这两个文件只选择一个来限制而已，因此，建议你只要保留一个即可，
		免得影响自己在设置上面的判断！一般来说，系统缺省是保留 /etc/cron.deny ，
		你可以将不想让他运行 crontab 的那个用户写入 /etc/cron.deny 当中，一个帐号一行！</p>
		<p><span class="text_import2">当用户使用 crontab 这个指令来创建工作调度之后，该项工作就会被纪录到 /var/spool/cron/ 
		里面去了，而且是以帐号来作为判别的喔</span>！举例来说， dmtsai 使用 crontab 后，
		他的工作会被纪录到 /var/spool/cron/dmtsai 里头去！但请注意，<span class="text_import2">不要使用 vi 直接编辑该文件，
		因为可能由于输入语法错误，会导致无法运行 cron 喔</span>！另外， cron 运行的每一项工作都会被纪录到
		/var/log/cron 这个注册表中，所以啰，如果你的 Linux 不知道有否被植入木马时，也可以搜索一下 /var/log/cron 
		这个注册表呢！</p>
		<a id="crontab"></a>
		<p>好了，那么我们就来聊一聊 crontab 的语法吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">crontab [-u username] [-l|-e|-r]</span>
<span class="term_say">选项与参数：
-u  ：只有 root 才能进行这个任务，亦即帮其他用户创建/移除 crontab 工作调度；
-e  ：编辑 crontab 的工作内容
-l  ：查阅 crontab 的工作内容
-r  ：移除所有的 crontab 的工作内容，若仅要移除一项，请用 -e 去编辑。</span>
<span class="term_hd">范例一：用 dmtsai 的身份在每天的 12:00 发信给自己</span>
[dmtsai@study ~]$ <span class="term_command">crontab -e</span>
<span class="term_say"># 此时会进入 vi 的编辑画面让您编辑工作！注意到，每项工作都是一行。</span>
<span class="term_write">0   12  *  *  * mail -s "at 12:00" dmtsai &lt; /home/dmtsai/.bashrc</span>
<span class="term_say">#分 时 日 月 周 |&lt;==============指令串========================&gt;|</span>
</pre></td></tr></tbody></table>
		<p>缺省情况下，任何用户只要不被列入 /etc/cron.deny 当中，那么他就可以直接下达『 crontab -e 
		』去编辑自己的例行性命令了！整个过程就如同上面提到的，会进入 vi 的编辑画面，
		然后以一个工作一行来编辑，编辑完毕之后输入『 :wq 』保存后离开 vi 就可以了！
		而每项工作 (每行) 的格式都是具有六个字段，这六个字段的意义为：</p>
<table class="news" style="width: 95%">
<tbody><tr class="theader"><td style="width: 90px">代表意义</td><td style="width: 70px">分钟</td><td style="width: 70px">小时</td>
	<td style="width: 70px">日期</td><td style="width: 70px">月份</td><td style="width: 70px">周</td><td>指令</td></tr>
<tr class="tcenter"><td style="background-color: lightblue">数字范围</td><td>0-59</td><td>0-23</td><td>1-31</td><td>1-12</td><td>0-7</td>
	<td>呀就指令啊</td></tr>
</tbody></table>
		<p>比较有趣的是那个『周』喔！周的数字为 0 或 7 时，都代表『星期天』的意思！另外，还有一些辅助的字符，大概有底下这些：</p>
<table class="news" style="width: 95%">
<tbody><tr class="theader"><td style="width: 70px">特殊字符</td><td>代表意义</td></tr>
<tr><td class="tcenter">*(星号)</td><td>代表任何时刻都接受的意思！举例来说，范例一内那个日、月、周都是 * ，
	就代表着『不论何月、何日的礼拜几的 12:00 都运行后续指令』的意思！</td></tr>
<tr><td class="tcenter">,(逗号)</td><td>代表分隔时段的意思。举例来说，如果要下达的工作是 3:00 与 6:00 时，就会是：
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;; margin-top: 5px; margin-bottom: 5px;">0 3,6 * * * command</blockquote>
	时间参数还是有五栏，不过第二栏是 3,6 ，代表 3 与 6 都适用！</td></tr>
<tr><td class="tcenter">-(减号)</td><td>代表一段时间范围内，举例来说， 8 点到 12 点之间的每小时的 20 分都进行一项工作：
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;; margin-top: 5px; margin-bottom: 5px;">20 8-12 * * * command</blockquote>
	仔细看到第二栏变成 8-12 喔！代表 8,9,10,11,12 都适用的意思！</td></tr>
<tr><td class="tcenter">/n(斜线)</td><td>那个 n 代表数字，亦即是『每隔 n 单位间隔』的意思，例如每五分钟进行一次，则：<br>
	<blockquote class="text_import2" style="font-family: &#39;细明体&#39;; margin-top: 5px; margin-bottom: 5px;">*/5 * * * * command</blockquote>
	很简单吧！用 * 与 /5 来搭配，也可以写成 0-59/5 ，相同意思！</td></tr>
</tbody></table>
		<p>我们就来搭配几个例子练习看看吧！底下的案例请实际用 dmtsai 
		这个身份作看看喔！后续的动作才能够搭配起来！</p>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
假若你的女朋友生日是 5 月 2 日，你想要在 5 月 1 日的 23:59 发一封信给他，这封信的内容已经写在
/home/dmtsai/lover.txt 内了，该如何进行？
</div>
答：<div>
直接下达 crontab -e 之后，编辑成为：<blockquote class="text_import2" style="font-family: &#39;细明体&#39;">
59 23 1 5  *  mail kiki &lt; /home/dmtsai/lover.txt</blockquote>
那样的话，每年 kiki 都会收到你的这封信喔！（当然啰，信的内容就要每年变一变啦！）
</div>
</td></tr></tbody></table><br>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
假如每五分钟需要运行  /home/dmtsai/test.sh 一次，又该如何？
</div>
答：<div>
同样使用 crontab -e 进入编辑：<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
*/5 * * * * /home/dmtsai/test.sh</blockquote>
</div>
</td></tr></tbody></table>
		<p>那个 crontab 每个人都只有一个文件存在，就是在 /var/spool/cron 里面啊！
		还有建议您：『<span class="text_import2">指令下达时，最好使用绝对路径，这样比较不会找不到运行档喔</span>！』</p>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
假如你每星期六都与朋友有约，那么想要每个星期五下午 4:30 告诉你朋友星期六的约会不要忘记，则：
</div>
答：<div>
还是使用 crontab -e 啊！<blockquote class="text_import2">
30 16 * * 5 mail friend@his.server.name &lt; /home/dmtsai/friend.txt</blockquote>
</div>
</td></tr></tbody></table>
		<p>真的是很简单吧！呵呵！那么，该如何查找用户目前的 crontab 内容呢？我们可以这样来看看：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">crontab -l</span>
0 12 * * * mail -s "at 12:00" dmtsai &lt; /home/dmtsai/.bashrc
59 23 1 5 * mail kiki &lt; /home/dmtsai/lover.txt
*/5 * * * * /home/dmtsai/test.sh
30 16 * * 5 mail friend@his.server.name &lt; /home/dmtsai/friend.txt
<span class="term_say"># 注意，若仅想要移除一项工作而已的话，必须要用 crontab -e 去编辑～
# 如果想要全部的工作都移除，才使用 crontab -r 喔！</span>
[dmtsai@study ~]$ <span class="term_command">crontab -r</span>
[dmtsai@study ~]$ <span class="term_command">crontab -l</span>
no crontab for dmtsai
</pre></td></tr></tbody></table>
		<p>看到了吗？ crontab 『整个内容都不见了！』所以请注意：『如果只是要删除某个 crontab 的工作项目，那么请使用 crontab -e 来重新编辑即可！』如果使用 -r 的参数，是会将所有的 
		crontab 数据内容都删掉的！千万注意了！</p>
	<br></div><br>
	<a id="etc_crontab1"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.3.2 系统的设置档： /etc/crontab, /etc/cron.d/*</h2>
		<p>这个『 crontab -e 』是针对用户的 cron 来设计的，如果是『系统的例行性任务』时，
		该怎么办呢？是否还是需要以 crontab -e 来管理你的例行性工作调度呢？当然不需要，你只要编辑
		<span class="text_import2">/etc/crontab</span> 这个文件就可以啦！有一点需要特别注意喔！那就是
		crontab -e 这个 crontab 其实是 /usr/bin/crontab 这个运行档，但是 /etc/crontab
		可是一个『纯文本档』喔！你可以 root 的身份编辑一下这个文件哩！</p>
		<p>基本上，<span class="text_import2"> cron 这个服务的最低侦测限制是『分钟』，所以『 cron
		会每分钟去读取一次 /etc/crontab 与 /var/spool/cron 里面的数据内容</span>
		』，因此，只要你编辑完 /etc/crontab 这个文件，并且将他保存之后，那么 
		cron 的设置就自动的会来运行了！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		在 Linux 底下的 crontab 会自动的帮我们每分钟重新读取一次 /etc/crontab 
		的例行工作事项，但是某些原因或者是其他的 Unix 系统中，由于 crontab 
		是读到内存当中的，所以在你修改完 /etc/crontab 之后，可能并不会马上运行，
		这个时候请重新启动 crond 这个服务吧！『systemctl restart crond』
		</fieldset><br>
		<a id="etc_crontab"></a>
		<p>废话少说，我们就来看一下这个 /etc/crontab 的内容吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">cat /etc/crontab</span>
SHELL=/bin/bash                     <span class="term_note">&lt;==使用哪种 shell 接口</span>
PATH=/sbin:/bin:/usr/sbin:/usr/bin  <span class="term_note">&lt;==运行档搜索路径</span>
MAILTO=root                         <span class="term_note">&lt;==若有额外STDOUT，以 email将数据送给谁</span>
# Example of job definition:
# .---------------- minute (0 - 59)
# |  .------------- hour (0 - 23)
# |  |  .---------- day of month (1 - 31)
# |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...
# |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat
# |  |  |  |  |
# *  *  *  *  * user-name  command to be executed
</pre></td></tr></tbody></table>
		<p>看到这个文件的内容你大概就了解了吧！呵呵，没错！这个文件与将刚刚我们下达 crontab -e 的内容几乎完全一模一样！只是有几个地方不太相同：</p>
		<div class="illus">
		<ul><li>MAILTO=root：</li></ul>
		<p>这个项目是说，当 /etc/crontab 这个文件中的例行性工作的指令发生错误时，或者是该工作的运行结果有 
		STDOUT/STDERR 时，会将错误消息或者是屏幕显示的消息传给谁？缺省当然是由系统直接寄发一封 mail 给 root 啦！不过，
		由于 root 并无法在用户端中以 POP3 之类的软件收信，因此，鸟哥通常都将这个 e-mail 
		改成自己的帐号，好让我随时了解系统的状况！例如：
		<span class="text_import2">MAILTO=dmtsai@my.host.name</span></p>
		<ul><li>PATH=....：</li></ul>
		<p>还记得我们在<a href="0320bash.html#env">第十章的 BASH</a> 当中一直提到的运行档路径问题吧！
		没错啦！这里就是输入运行档的搜索路径！使用缺省的路径设置就已经很足够了！</p>
		<ul><li>『分 时 日 月 周 身份 指令』七个字段的设置</li></ul>
		<p>这个 /etc/crontab 里面可以设置的基本语法与 crontab -e 不太相同喔！前面同样是分、时、日、月、周五个字段，
		但是在五个字段后面接的并不是指令，而是一个新的字段，那就是『<span class="text_import2">运行后面那串指令的身份</span>』为何！这与用户的 crontab -e 不相同。由于用户自己的 
		crontab 并不需要指定身份，但 /etc/crontab 里面当然要指定身份啦！以上表的内容来说，系统缺省的例行性工作是以 root
		的身份来进行的。</p>
		</div>
		<ul class="toplist"><li>crond 服务读取设置档的位置</li></ul>
		<p>一般来说，crond 缺省有三个地方会有运行脚本设置档，他们分别是：</p>
		<ul class="text_import2">
		<li>/etc/crontab</li>
		<li>/etc/cron.d/*</li>
		<li>/var/spool/cron/*</li>
		</ul>
		<p>这三个地方中，跟系统的运作比较有关系的两个设置档是放在 /etc/crontab 文件内以及 /etc/cron.d/* 目录内的文件，
		另外一个是跟用户自己的工作比较有关的设置档，就是放在 /var/spool/cron/ 里面的文件群。
		现在我们已经知道了 /var/spool/cron 以及 /etc/crontab 的内容，那现在来瞧瞧 /etc/cron.d 里面的东西吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">ls -l /etc/cron.d</span>
-rw-r--r--. 1 root root 128 Jul 30  2014 0hourly
-rw-r--r--. 1 root root 108 Mar  6 10:12 raid-check
-rw-------. 1 root root 235 Mar  6 13:45 sysstat
-rw-r--r--. 1 root root 187 Jan 28  2014 unbound-anchor
<span class="term_say"># 其实说真的，除了 /etc/crontab 之外，crond 的设置档还不少耶！上面就有四个设置！
# 先让我们来瞧瞧 0hourly 这个设置档的内容吧！</span>
[root@study ~]# <span class="term_command">cat /etc/cron.d/0hourly</span>
# Run the hourly jobs
SHELL=/bin/bash
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
<span class="term_write">01 * * * * root run-parts /etc/cron.hourly</span>
<span class="term_say"># 瞧一瞧，内容跟 /etc/crontab 几乎一模一样！但实际上是有设置值喔！就是最后一行！</span>
</pre></td></tr></tbody></table>
		<p>如果你想要自己开发新的软件，该软件要拥有自己的 crontab 定时指令时，就可以将『分、时、日、月、周、身份、指令』的设置档放置到 /etc/cron.d/ 目录下！
		在此目录下的文件是『crontab 的设置档脚本』。</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		以鸟哥来说，现在鸟哥有在开发一些虚拟化教室的软件，该软件需要定时清除一些垃圾防火墙规则，
		那鸟哥就是将要运行的时间与指令设计好，然后直接将设置写入到 /etc/cron.d/newfile 即可！未来如果这个软件要升级，
		直接将该文件覆盖成新文件即可！比起手动去分析 /etc/crontab 要单纯的多！
		</fieldset><br>
		<p>另外，请注意一下上面表格中提到的最后一行，每个整点的一分会运行『 run-parts /etc/cron.hourly 』这个指令～咦！那什么是 run-parts 呢？
		如果你有去分析一下这个运行档，会发现他就是 shell script，<span class="text_import2">run-parts 脚本会在大约 5 分钟内随机选一个时间来运行 
		/etc/cron.hourly 目录内的所有运行档！因此，放在 /etc/cron.hourly/ 的文件，必须是能被直接运行的指令脚本，
		而不是分、时、日、月、周的设置值喔</span>！注意注意！</p>
		<p>也就是说，除了自己指定分、时、日、月、周加上指令路径的 crond 设置档之外，你也可以直接将指令放置到(或链接到)/etc/cron.hourly/ 目录下，
		则该指令就会被 crond 在每小时的 1 分开始后的 5 分钟内，随机取一个时间点来运行啰！你无须手动去指定分、时、日、月、周就是了。</p>
		<p>但是眼尖的朋友可能还会发现，除了可以直接将指令放到 /etc/cron.hourly/ 让系统每小时定时运行之外，在 /etc/ 底下其实还有
		/etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/，那三个目录是代表每日、每周、每月各运行一次的意思吗？嘿嘿！
		厉害喔！没错～是这样～不过，跟 /etc/cron.hourly/ 不太一样的是，那三个目录是由 anacron 所运行的，而 anacron 的运行方式则是放在 
		/etc/cron.hourly/0anacron 里面耶～跟前几代 anacron 是单独的 service 不太一样喔！这部份留待下个小节再来讨论。</p>
		<p>最后，让我们总结一下吧：</p>
		<ul>
		<li>个人化的行为使用『 crontab -e 』：如果你是依据个人需求来创建的例行工作调度，建议直接使用 crontab -e 来创建你的工作调度较佳！
		这样也能保障你的指令行为不会被大家看到 (/etc/crontab 是大家都能读取的权限喔！)；</li>
		<li style="margin-top: 10px">系统维护管理使用『 vim /etc/crontab 』：如果你这个例行工作调度是系统的重要工作，为了让自己管理方便，同时容易追踪，建议直接写入 /etc/crontab 较佳！</li>
		<li style="margin-top: 10px">自己开发软件使用『 vim /etc/cron.d/newfile 』：如果你是想要自己开发软件，那当然最好就是使用全新的设置档，并且放置于 /etc/cron.d/ 目录内即可。</li>
		<li style="margin-top: 10px">固定每小时、每日、每周、每天运行的特别工作：如果与系统维护有关，还是建议放置到 /etc/crontab 中来集中管理较好。
		如果想要偷懒，或者是一定要再某个周期内进行的任务，也可以放置到上面谈到的几个目录中，直接写入指令即可！</li>
		</ul>
	<br></div><br>
	<a id="security"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.3.3 一些注意事项</h2>
		<p>有的时候，我们以系统的 cron 来进行例行性工作的创建时，要注意一些使用方面的特性。
		举例来说，如果我们有四个工作都是五分钟要进行一次的，那么是否这四个动作全部都在同一个时间点进行？
		如果同时进行，该四个动作又很耗系统资源，如此一来，每五分钟的某个时刻不是会让系统忙得要死？
		呵呵！此时好好的分配一些运行时间就 OK 啦！所以，注意一下：</p>
		<ul class="toplist"><li>资源分配不均的问题</li></ul>
		<p>当大量使用 crontab 的时候，总是会有问题发生的，最严重的问题就是『系统资源分配不均』的问题，
		以鸟哥的系统为例，我有侦测主机流量的信息，包括：</p>
		<ul>
		<li>流量</li>
		<li>区域内其他 PC 的流量侦测</li>
		<li>CPU 使用率</li>
		<li>RAM 使用率</li>
		<li>在线人数即时侦测</li></ul>
		<p>如果每个流程都在同一个时间启动的话，那么在某个时段时，我的系统会变的相当的繁忙，所以，这个时候就必须要分别设置啦！我可以这样做：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">vim /etc/crontab</span>
1,6,11,16,21,26,31,36,41,46,51,56 * * * * root  CMD1
2,7,12,17,22,27,32,37,42,47,52,57 * * * * root  CMD2
3,8,13,18,23,28,33,38,43,48,53,58 * * * * root  CMD3
4,9,14,19,24,29,34,39,44,49,54,59 * * * * root  CMD4
</pre></td></tr></tbody></table>
		<p>看到了没？那个『 , 』分隔的时候，请注意，不要有空白字符！（连续的意思）如此一来，
		则可以将每五分钟工作的流程分别在不同的时刻来工作！则可以让系统的运行较为顺畅呦！</p>
		<ul class="toplist"><li>取消不要的输出项目</li></ul>
		<p>另外一个困扰发生在『 <span class="text_import2">当有运行成果或者是运行的项目中有输出的数据时，该数据将会
		mail 给 MAILTO 设置的帐号</span> 』，好啦，那么当有一个调度一直出错（例如 DNS
		的侦测系统当中，若 DNS 上层主机挂掉，那么你就会一直收到错误消息！）怎么办？呵呵！还记得<a href="0320bash.html#redirect">第十章谈到的数据流重导向</a>吧？
		直接以『数据流重导向』将输出的结果输出到 <span class="text_import2">/dev/null</span> 这个垃圾桶当中就好了！</p>
		<ul class="toplist"><li>安全的检验</li></ul>
		<p>很多时候被植入木马都是以例行命令的方式植入的，所以可以借由检查 /var/log/cron
		的内容来视察是否有『非您设置的 cron 被运行了？』这个时候就需要小心一点啰！</p>
		<ul class="toplist"><li>周与日月不可同时并存</li></ul>
		<p>另一个需要注意的地方在于：『你可以分别以周或者是日月为单位作为循环，但你不可使用「几月几号且为星期几」的模式工作』。
		这个意思是说，你不可以这样编写一个工作调度：</p>
<table class="term"><tbody><tr><td class="term"><pre>30 12 11 9 5 root echo "just test"   <span class="term_note">&lt;==这是错误的写法</span>
</pre></td></tr></tbody></table>
		<p>本来你以为九月十一号且为星期五才会进行这项工作，无奈的是，系统可能会判定每个星期五作一次，或每年的 9 月 11 
		号分别进行，如此一来与你当初的规划就不一样了～所以啰，得要注意这个地方！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		根据某些人的说法，这个月日、周不可并存的问题已经在新版中被克服了～不过，鸟哥并没有实际去验证他！目前也不打算验证他！
		因为，周就是周，月日就月日，单一运行点就单一运行点，无须使用 crontab 去设置固定的日期啊！您说是吧？
		</fieldset><br>	</div>
</div>
<a id="anacron_1"></a>
<div class="block1">
<h2>15.4 可唤醒停机期间的工作任务</h2>
	<p>想像一个环境，你的 Linux 服务器有一个工作是需要在每周的星期天凌晨 2 点进行，但是很不巧的，星期六停电了～所以你得要星期一才能进公司去启动服务器。
	那么请问，这个星期天的工作调度还要不要进行？因为你开机的时候已经是星期一，所以星期天的工作当然不会被进行，对吧！</p>
	<p>问题是，若是该工作非常重要 (例如例行备份)，
	所以其实你还是希望在下个星期天之前的某天还是进行一下比较好～那你该怎办？自己手动运行？如果你跟鸟哥一样是个记忆力超差的家伙，那么肯定『记不起来某个重要工作要进行』的啦！
	这时候就得要靠 anacron 这个指令的功能了！这家伙可以主动帮你进行时间到了但却没有运行的调度喔！</p>
	<a id="anacron_what"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.4.1 什么是 anacron</h2>
		<p>anacron 并不是用来取代 crontab 的，anacron 存在的目的就在于我们上头提到的，在处理非 24 小时一直启动的 Linux 系统的 crontab 的运行！
		以及因为某些原因导致的超过时间而没有被运行的调度工作。</p>
		<p>其实 anacron 也是每个小时被 crond 运行一次，然后 anacron 再去检测相关的调度任务有没有被运行，如果有超过期限的工作在，
		就运行该调度任务，运行完毕或无须运行任何调度时，anacron 就停止了。</p>
		<p>由于 anacron 缺省会以一天、七天、一个月为期去侦测系统未进行的 crontab 任务，因此对于某些特殊的使用环境非常有帮助。
		举例来说，如果你的 Linux 主机是放在公司给同仁使用的，因为周末假日大家都不在所以也没有必要开启，
		因此你的 Linux 是周末都会关机两天的。但是 crontab 大多在每天的凌晨以及周日的早上进行各项任务，
		偏偏你又关机了，此时系统很多 crontab 的任务就无法进行。 anacron 刚好可以解决这个问题！</p>
		<p>那么 anacron 又是怎么知道我们的系统啥时关机的呢？这就得要使用 anacron 读取的时间记录档 (timestamps) 了！
		anacron 会去分析现在的时间与时间记录档所记载的上次运行 anacron 的时间，两者比较后若发现有差异，
		那就是在某些时刻没有进行 crontab 啰！此时 anacron 就会开始运行未进行的 crontab 任务了！</p>
	<br></div><br>
	<a id="anacron"></a>
	<div class="block2"><div class="gototop"><a href="0430cron.html#top">Top</a></div>
	<h2>15.4.2 anacron 与 /etc/anacrontab</h2>
		<p>anacron 其实是一支程序并非一个服务！这支程序在 CentOS 当中已经进入 crontab 的调度喔！同时 anacron 会每个小时被主动运行一次喔！
		咦！每个小时？所以 anacron 的设置档应该放置在 /etc/cron.hourly 吗？嘿嘿！您真内行～赶紧来瞧一瞧：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">cat /etc/cron.hourly/0anacron</span>
#!/bin/sh
# Check whether 0anacron was run today already
if test -r /var/spool/anacron/cron.daily; then
    day=`cat /var/spool/anacron/cron.daily`
fi
if [ `date +%Y%m%d` = "$day" ]; then
    exit 0;
fi
<span class="term_say"># 上面的语法在检验前一次运行 anacron 时的时间戳记！</span>
# Do not run jobs when on battery power
if test -x /usr/bin/on_ac_power; then
    /usr/bin/on_ac_power &gt;/dev/null 2&gt;&amp;1
    if test $? -eq 1; then
    exit 0
    fi
fi
/usr/sbin/anacron -s
<span class="term_say"># 所以其实也仅是运行 anacron -s 的指令！因此我们得来谈谈这支程序！</span>
</pre></td></tr></tbody></table>
		<p>基本上， anacron 的语法如下：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">anacron [-sfn] [job]..</span>
[root@study ~]# <span class="term_command">anacron -u [job]..</span>
<span class="term_say">选项与参数：
-s  ：开始一连续的运行各项工作 (job)，会依据时间记录档的数据判断是否进行；
-f  ：强制进行，而不去判断时间记录档的时间戳记；
-n  ：立刻进行未进行的任务，而不延迟 (delay) 等待时间；
-u  ：仅更新时间记录档的时间戳记，不进行任何工作。
job ：由 /etc/anacrontab 定义的各项工作名称。</span>
</pre></td></tr></tbody></table>
		<p>在我们的 CentOS 中，anacron 的进行其实是在每个小时都会被抓出来运行一次，
		但是为了担心 anacron 误判时间参数，因此 /etc/cron.hourly/ 里面的 anacron 才会在文件名之前加个 0 
		(0anacron)，让 anacron 最先进行！就是为了让时间戳记先更新！以避免 anacron 误判 crontab 
		尚未进行任何工作的意思。</p>
		<p>接下来我们看一下 anacron 的设置档： /etc/anacrontab 的内容好了：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">cat /etc/anacrontab</span>
SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin
MAILTO=root
RANDOM_DELAY=45           <span class="term_note"># 随机给予最大延迟时间，单位是分钟</span>
START_HOURS_RANGE=3-22    <span class="term_note"># 延迟多少个小时内应该要运行的任务时间</span>
<span style="text-decoration: underline">1         5        cron.daily         nice run-parts /etc/cron.daily</span>
7        25        cron.weekly        nice run-parts /etc/cron.weekly
@monthly 45        cron.monthly       nice run-parts /etc/cron.monthly
<span class="term_say">天数     延迟时间  工作名称定义       实际要进行的指令串
# 天数单位为天；延迟时间单位为分钟；工作名称定义可自订，指令串则通常与 crontab 的设置相同！</span>
[root@study ~]# <span class="term_command">more /var/spool/anacron/*</span>
::::::::::::::
/var/spool/anacron/cron.daily
::::::::::::::
<span style="text-decoration: underline">20150731</span>
::::::::::::::
/var/spool/anacron/cron.monthly
::::::::::::::
20150703
::::::::::::::
/var/spool/anacron/cron.weekly
::::::::::::::
20150727
<span class="term_say"># 上面则是三个工作名称的时间记录档以及记录的时间戳记</span>
</pre></td></tr></tbody></table>
		<p>我们拿 /etc/cron.daily/ 那一行的设置来说明好了。那四个字段的意义分别是：</p>
		<ul>
		<li>天数：anacron 运行当下与时间戳记 (/var/spool/anacron/ 内的时间纪录档) 相差的天数，若超过此天数，就准备开始运行，若没有超过此天数，则不予运行后续的指令。</li>
		<li>延迟时间：若确定超过天数导致要运行调度工作了，那么请延迟运行的时间，因为担心立即启动会有其他资源冲突的问题吧！</li>
		<li>工作名称定义：这个没啥意义，就只是会在 /var/log/cron 里头记载该项任务的名称这样！通常与后续的目录资源名称相同即可。</li>
		<li>实际要进行的指令串：有没有跟 0hourly 很像啊！没错！相同的作法啊！透过 run-parts 来处理的！</li>
		</ul>
		<p>根据上面的设置档内容，我们大概知道 anacron 的运行流程应该是这样的 (以 cron.daily 为例)：</p>
		<ol class="text_import2">
		<li>由 /etc/anacrontab 分析到 cron.daily 这项工作名称的天数为 1 天；</li>
		<li>由 /var/spool/anacron/cron.daily 取出最近一次运行 anacron 的时间戳记；</li>
		<li>由上个步骤与目前的时间比较，若差异天数为 1 天以上 (含 1 天)，就准备进行指令；</li>
		<li>若准备进行指令，根据 /etc/anacrontab 的设置，将延迟 5 分钟 + 3 小时 (看 START_HOURS_RANGE 的设置)；</li>
		<li>延迟时间过后，开始运行后续指令，亦即『 run-parts /etc/cron.daily 』这串指令；</li>
		<li>运行完毕后， anacron 程序结束。</li>
		</ol>
		<p>如此一来，放置在 /etc/cron.daily/ 内的任务就会在一天后一定会被运行的！因为 anacron 是每个小时被运行一次嘛！
		所以，现在你知道<span class="text_import2">为什么隔了一阵子才将 CentOS 开机，开机过后约 1 
		小时左右系统会有一小段时间的忙碌！而且硬盘会跑个不停！那就是因为 anacron 正在运行过去 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 
		里头的未进行的各项工作调度啦！</span>这样对 anacron 有没有概念了呢？ ^_^</p>
		<p>最后，我们来总结一下本章谈到的许多设置档与目录的关系吧！这样我们才能了解 crond 与 anacron 的关系：</p>
		<ol>
		<li>crond 会主动去读取 /etc/crontab, /var/spool/cron/*, /etc/cron.d/* 等设置档，并依据『分、时、日、月、周』的时间设置去各项工作调度；</li>
		<li>根据 /etc/cron.d/0hourly 的设置，主动去 /etc/cron.hourly/ 目录下，运行所有在该目录下的运行档；</li>
		<li>因为 /etc/cron.hourly/0anacron 这个指令档的缘故，主动的每小时运行 anacron ，并调用 /etc/anacrontab 的设置档；</li>
		<li>根据 /etc/anacrontab 的设置，依据每天、每周、每月去分析 /etc/cron.daily/, /etc/cron.weekly/, /etc/cron.monthly/ 内的运行档，以进行固定周期需要运行的指令。</li>
		</ol>
		<p>也就是说，如果你每个周日的需要运行的动作是放置于 /etc/crontab 的话，那么该动作只要过期了就过期了，并不会被抓回来重新运行。但如果是放置在
		/etc/cron.weekly/ 目录下，那么该工作就会定期，几乎一定会在一周内运行一次～如果你关机超过一周，那么一开机后的数个小时内，该工作就会主动的被运行喔！
		真的吗？对啦！因为 /etc/anacrontab 的定义啦！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		基本上，crontab 与 at 都是『定时』去运行，过了时间就过了！不会重新来一遍～那 anacron 则是『定期』去运行，某一段周期的运行～
		因此，两者可以并行，并不会互相冲突啦！
		</fieldset><br>	</div>
</div>
<a id="hint"></a>
<div class="block1">
<h2>15.5 重点回顾</h2>
<ul class="text_import2">
	<li>系统可以透过 at 这个指令来调度单一工作的任务！『at TIME』为指令下达的方法，当 at 进入调度后，
	系统运行该调度工作时，会到下达时的目录进行任务；</li>
	<li>at 的运行必须要有 atd 服务的支持，且 /etc/at.deny 为控制是否能够运行的用户帐号；</li>
	<li>透过 atq, atrm 可以查找与删除 at 的工作调度；</li>
	<li>batch 与 at 相同，不过 batch 可在 CPU 工作负载小于 0.8 时才进行后续的工作调度；</li>
	<li>系统的循环例行性工作调度使用 crond 这个服务，同时利用 crontab -e 及 /etc/crontab 进行调度的安排；</li>
	<li>crontab -e 设置项目分为六栏，『分、时、日、月、周、指令』为其设置依据；</li>
	<li>/etc/crontab 设置分为七栏，『分、时、日、月、周、运行者、指令』为其设置依据；</li>
	<li>anacron 配合 /etc/anacrontab  的设置，可以唤醒停机期间系统未进行的 crontab 任务！</li>
</ul>
</div>
<a id="ex"></a>
<div class="block1">
<h2>15.6 本章习题</h2>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
简答题：
<ul>
	<li>今天假设我有一个指令程序，名称为： ping.sh 这个文件名！我想要让系统每三分钟运行这个文件一次，
	但是偏偏这个文件会有很多的消息显示出来，所以我的
	root 帐号每天都会收到差不多四百多封的信件，光是收信就差不多快要疯掉了！
	那么请问应该怎么设置比较好呢？
	<div class="blockex">
		这个涉及数据流重导向的问题，我们可以将他导入文件或者直接丢弃！如果该消息不重要的话，
		那么就予以丢弃，如果消息很重要的话，才将他保留下来！假设今天这个命令不重要，
		所以将他丢弃掉！因此，可以这样写：<blockquote>
		*/3 * * * * root /usr/local/ping.sh &gt; /dev/null 2&gt;&amp;1</blockquote>
	</div></li>
	<li>您预计要在 2016 年的 2 月 14 日寄出一封给 kiki ，只有该年才寄出！该如何下达指令？
	<div class="blockex">
		at 1am 2016-02-14
	</div></li>
	<li>下达 crontab -e 之后，如果输入这一行，代表什么意思？<br>
	* 15 * * 1-5 /usr/local/bin/tea_time.sh
	<div class="blockex">
		在每星期的 1~5 ，下午 3 点的每分钟，共进行 60 次 /usr/local/bin/tea_time.sh 这个文件。
		要特别注意的是，每个星期 1~5 的 3 点都会进行 60 次ㄟ！很麻烦吧～是错误的写法啦～
		应该是要写成：<br>
		30 15 * * 1-5 /usr/local/bin/tea_time.sh
	</div></li>
	<li>我用 vi 编辑 /etc/crontab 这个文件，我编辑的那一行是这样的：<br>
	25 00 * * 0   /usr/local/bin/backup.sh<br>
	这一行代表的意义是什么？
	<div class="blockex">
		这一行代表......没有任何意义！因为语法错误！您必须要了解，在 /etc/crontab 
		当中每一行都必须要有用户才行！所以，应该要将原本那行改成：<br>
		25 00 * * 0 root  /usr/local/bin/backup.sh
	</div></li>
	<li>请问，您的系统每天、每周、每个月各有进行什么工作？
	<div class="blockex">
		因为 CentOS 系统缺省的例行性命令都放置在 /etc/cron.* 里面，所以，你可以自行去：
		/etc/cron.daily/, /etc/cron.week/, /etc/cron.monthly/ 这三个目录内看一看，
		就知道啦！ ^_^
	</div></li>
	<li>每个星期六凌晨三点去系统搜索一下内有 SUID/SGID 的任何文件！并将结果输出到 /tmp/uidgid.files
	<div class="blockex">
		vi /etc/crontab<br>
		0 3 * * 6 root find / -perm /6000 &gt; /tmp/uidgid.files
	</div></li>
</ul>
</div>
</div>	<!-- mainarea -->
</div>  
</body></html>