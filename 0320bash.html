<!DOCTYPE html>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
	
	<meta name="Author" content="VBird, 鸟哥">
	<meta name="Description" content="学习 bash shell">
	<title>鸟哥的 Linux 私房菜 -- 第十章、认识与学习BASH</title>
	<style type="text/css">
	</style>
	<link href="./vbird_files/style_2013.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="tablearea">
<div class="mainarea">
<div class="block1">
<!-- 本文的档头部分 -->
<h1>第十章、认识与学习BASH</h1>
<div style="text-align:right">
	<span class="text_history">最近更新日期：2015/07/09</span>
</div>
<!-- 本文的档头部分 -->
<div class="abstract">
	<p>在 Linux 的环境下，如果你不懂 bash 是什么，那么其他的东西就不用学了！因为前面几章我们使用终端机下达指令的方式，
	就是透过 bash 的环境来处理的喔！所以说，他很重要吧！bash 的东西非常的多，包括变量的设置与使用、
	bash 操作环境的建置、数据流重导向的功能，还有那好用的管线命令！好好清一清脑门，准备用功去啰～ ^_^
	这个章节几乎是所有指令列模式 (command line) 与未来主机维护与管理的重要基础，一定要好好仔细的阅读喔！</p>
</div>
<!-- 本文的链接区部分 -->
<div class="links">
<ul>
	<li><a href="0320bash.html#bash">10.1 认识 BASH 这个 Shell</a>
	<ul>
		<li><a href="0320bash.html#bash_what">10.1.1 硬件、核心与 Shell</a></li>
		<li><a href="0320bash.html#bash_why">10.1.2 为何要学文本接口的 shell</a></li>
		<li><a href="0320bash.html#bash_shells">10.1.3 系统的合法 shell 与 /etc/shells 功能</a></li>
		<li><a href="0320bash.html#bash_bash">10.1.4 Bash shell 的功能</a></li>
		<li><a href="0320bash.html#bash_type">10.1.5 查找指令是否为 Bash shell 的内置命令： type</a></li>
		<li><a href="0320bash.html#bash_command">10.1.6 指令的下达与快速编辑按钮</a></li>
	</ul></li>
	<li><a href="0320bash.html#variable">10.2 Shell 的变量功能</a>
	<ul>
		<li><a href="0320bash.html#variable_var">10.2.1 什么是变量？</a></li>
		<li><a href="0320bash.html#variable_echo">10.2.2 变量的取用与设置</a>：<a href="0320bash.html#echo">echo</a>, 
			<a href="0320bash.html#variable_rule">变量设置规则</a>, <a href="0320bash.html#unset">unset</a></li>
		<li><a href="0320bash.html#variable_environ">10.2.3 环境变量的功能</a>：
			<a href="0320bash.html#env">env 与常见环境变量说明</a>, 
			<a href="0320bash.html#set">set</a>, <a href="0320bash.html#export">export</a></li>
		<li><a href="0320bash.html#variable_locale">10.2.4 影响显示结果的语系变量 (locale)</a></li>
		<li><a href="0320bash.html#variable_range">10.2.5 变量的有效范围</a></li>
		<li><a href="0320bash.html#variable_read">10.2.6 变量键盘读取、数组与声明</a>： <a href="0320bash.html#read">read</a>, 
			<a href="0320bash.html#declare">declare</a>, <a href="0320bash.html#array">array</a></li>
		<li><a href="0320bash.html#variable_ulimit">10.2.7 与文件系统及进程的限制关系： ulimit</a></li>
		<li><a href="0320bash.html#variable_other">10.2.8 变量内容的删除、取代与替换 (Optional)：</a>, 
			<a href="0320bash.html#variable_other_replace">删除与取代</a>,
			<a href="0320bash.html#variable_other_re">测试与替换</a></li>
	</ul></li>
	<li><a href="0320bash.html#alias_history">10.3 命令别名与历史命令</a>
	<ul>
		<li><a href="0320bash.html#alias">10.3.1 命令别名设置： alias, unalias</a></li>
		<li><a href="0320bash.html#history">10.3.2 历史命令： history, HISTSIZE</a></li>
	</ul></li>
	<li><a href="0320bash.html#settings">10.4 Bash shell 的操作环境</a>
	<ul>
		<li><a href="0320bash.html#settings_path">10.4.1 路径与指令搜索顺序</a></li>
		<li><a href="0320bash.html#settings_issue">10.4.2 bash 的进站与欢迎消息： /etc/issue, /etc/motd</a></li>
		<li><a href="0320bash.html#settings_bashrc">10.4.3 环境设置档:</a>
			<a href="0320bash.html#settings_bashrc_shell">login, non-login shell</a>, 
			<a href="0320bash.html#settings_bashrc_profile">/etc/profile</a>, 
			<a href="0320bash.html#settings_bashrc_bash_profile">~/.bash_profile</a>, 
			<a href="0320bash.html#source">source</a>, 
			<a href="0320bash.html#settings_bashrc_bashrc">~/.bashrc</a></li>
		<li><a href="0320bash.html#settings_set">10.4.4 终端机的环境设置： stty, set</a></li>
		<li><a href="0320bash.html#settings_wildcard">10.4.5 通配符与特殊符号</a></li>
	</ul></li>
	<li><a href="0320bash.html#redirect">10.5 数据流重导向 (Redirection)</a>
	<ul>
		<li><a href="0320bash.html#redirect_redirect">10.5.1 何谓数据流重导向？</a></li>
		<li><a href="0320bash.html#redirect_com">10.5.2 命令运行的判断依据： ; , &amp;&amp;, ||</a></li>
	</ul></li>
	<li><a href="0320bash.html#pipe">10.6 管线命令 (pipe)</a>
	<ul>
		<li><a href="0320bash.html#pipe_1">10.6.1 截取命令：</a> <a href="0320bash.html#cut">cut</a>, <a href="0320bash.html#grep">grep</a></li>
		<li><a href="0320bash.html#pipe_2">10.6.2 排序命令：</a> <a href="0320bash.html#sort">sort</a>, <a href="0320bash.html#uniq">uniq</a>, 
			<a href="0320bash.html#wc">wc</a></li>
		<li><a href="0320bash.html#pipe_3">10.6.3 双向重导向：</a> <a href="0320bash.html#tee">tee</a></li>
		<li><a href="0320bash.html#pipe_4">10.6.4 字符转换命令：</a> <a href="0320bash.html#tr">tr</a>, <a href="0320bash.html#col">col</a>, 
			<a href="0320bash.html#join">join</a>, <a href="0320bash.html#paste">paste</a>, <a href="0320bash.html#expand">expand</a></li>
		<li><a href="0320bash.html#split">10.6.5 分割命令： split</a></li>
		<li><a href="0320bash.html#xargs">10.6.6 参数代换： xargs</a></li>
		<li><a href="0320bash.html#pipe_7">10.6.7 关于减号 - 的用途</a></li>
	</ul></li>
	<li><a href="0320bash.html#hint">10.7 重点回顾</a></li>
	<li><a href="0320bash.html#ex">10.8 本章习题</a></li>
	<li><a href="0320bash.html#reference">10.9 参考数据与延伸阅读</a></li>
</ul>
</div>
</div>
<!-- 本文的正式部分 -->
<a id="bash"></a>
<div class="block1">
<h2>10.1 认识 BASH 这个 Shell</h2>
	<p>我们在<a href="0110whatislinux.html">第一章 Linux 是什么</a>当中提到了：
	管理整个电脑硬件的其实是操作系统的核心 (kernel)，这个核心是需要被保护的！
	所以我们一般用户就只能透过 shell 来跟核心沟通，以让核心达到我们所想要达到的工作。
	那么系统有多少 shell 可用呢？为什么我们要使用 bash 啊？底下分别来谈一谈喔！</p>
	<a id="bash_what"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.1 硬件、核心与 Shell</h2>
		<p>这应该是个蛮有趣的话题：『<span class="text_import2">什么是 Shell</span> 』？相信只要摸过电脑，对于操作系统 (不论是 Linux 、 Unix 或者是 Windows) 
		有点概念的朋友们大多听过这个名词，因为只要有『操作系统』那么就离不开
		Shell 这个东西。不过，在讨论 Shell 之前，我们先来了解一下电脑的运作状况吧！
		举个例子来说：<span class="text_import2">当你要电脑传输出来『音乐』的时候，你的电脑需要什么东西呢</span>？</p>
		<ol>
		<li>硬件：当然就是需要你的硬件有『声卡芯片』这个配备，否则怎么会有声音；</li>
		<li>核心管理：操作系统的核心可以支持这个芯片组，当然还需要提供芯片的驱动程序啰；</li>
		<li>应用程序：需要用户 (就是你) 输入发生声音的指令啰！</li>
		</ol>
		<p>这就是基本的一个输出声音所需要的步骤！也就是说，你必须要『输入』一个指令之后，
		『硬件』才会透过你下达的指令来工作！那么硬件如何知道你下达的指令呢？那就是
		kernel (核心) 的控制工作了！也就是说，<span class="text_import2">我们必须要透过『
		Shell 』将我们输入的指令与 Kernel 沟通，好让 Kernel 可以控制硬件来正确无误的工作</span>！
		基本上，我们可以透过底下这张图来说明一下：</p>
	<a id="fig10.1.1"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/0320bash_1.jpg" alt="硬件、核心与用户的相关性图标" title="硬件、核心与用户的相关性图标" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.1.1、硬件、核心与用户的相关性图标</div>
		<p>我们在<a href="0105computers.html#program_os">第零章内的操作系统小节</a>曾经提到过，
		<span class="text_import2">操作系统其实是一组软件，由于这组软件在控制整个硬件与管理系统的活动监测，
		如果这组软件能被用户随意的操作，若用户应用不当，将会使得整个系统崩溃</span>！因为操作系统管理的就是整个硬件功能嘛！
		所以当然不能够随便被一些没有管理能力的终端用户随意使用啰！</p>
		<p>但是我们总是需要让用户操作系统的，所以就有了在操作系统上面发展的应用程序啦！用户可以透过应用程序来指挥核心，
		让核心达成我们所需要的硬件任务！如果考虑如<a href="0105computers/os_01.gif" target="_blank">第零章所提供的操作系统图标(图0.4.2)</a>，
		我们可以发现应用程序其实是在最外层，就如同鸡蛋的外壳一样，因此这个咚咚也就被称呼为壳程序 (shell) 啰！</p>
		<p>其实壳程序的功能只是提供用户操作系统的一个接口，因此这个壳程序需要可以调用其他软件才好。
		我们在第四章到第九章提到过很多指令，包括 man, chmod, chown, vi, fdisk, mkfs 等等指令，这些指令都是独立的应用程序，
		但是我们可以透过壳程序 (就是指令列模式) 来操作这些应用程序，让这些应用程序调用核心来运作所需的工作哩！
		这样对于壳程序是否有了一定的概念了？</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		也就是说，只要能够操作应用程序的接口都能够称为壳程序。狭义的壳程序指的是指令列方面的软件，包括本章要介绍的 bash 等。
		广义的壳程序则包括图形接口的软件！因为图形接口其实也能够操作各种应用程序来调用核心工作啊！
		不过在本章中，我们主要还是在使用 bash 啦！
		</fieldset><br>	</div><br>
	<a id="bash_why"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.2 为何要学文本接口的 shell？</h2>
		<p><span class="text_import2">文本接口的 shell 是很不好学的，但是学了之后好处多多</span>！所以，
		在这里鸟哥要先对您进行一些心理建设，先来了解一下为啥学习 shell 是有好处的，这样你才会有信心继续玩下去 ^_^
		</p>
		<ul class="toplist"><li>文本接口的 shell：大家都一样！</li></ul>
		<p>鸟哥常常听到这个问题：『<span class="text_import2">我干嘛要学习 shell 呢？
		不是已经有很多的工具可以提供我设置我的主机了？我为何要花这么多时间去学指令呢？不是以
		X Window 按一按几个按钮就可以搞定了吗？</span>』唉～还是得一再地强调，
		X Window 还有 Web 接口的设置工具例如 Webmin (<a href="0320bash.html#ps1">注1</a>) 是真的好用的家伙，
		他真的可以帮助我们很简易的设置好我们的主机，甚至是一些很高端的设置都可以帮我们搞定。</p>
		<p>但是鸟哥在前面的章节里面也已经提到过相当多次了， X Window 与 web 接口的工具，他的接口虽然亲善，功能虽然强大，
		但毕竟他是将所有利用到的软件都集成在一起的一组应用程序而已，
		并非是一个完整的套件，所以某些时候当你升级或者是使用其他套件管理模块 (例如 tarball 而非 rpm 文件等等)
		时，就会造成设置的困扰了。甚至不同的 distribution 所设计的 X window 接口也都不相同，这样也造成学习方面的困扰。</p>
		<p>文本接口的 shell 就不同了！几乎各家 distributions 使用的 bash 都是一样的！如此一来，
		你就能够轻轻松松的转换不同的 distributions ，就像武侠小说里面提到的『一法通、万法通！』</p>
		<ul class="toplist"><li>远程管理：文本接口就是比较快！</li></ul>
		<p>此外，Linux 的管理常常需要透过远程连接，而连接时<span class="text_import2">文本接口的传输速度一定比较快，
		而且，较不容易出现断线或者是信息外流的问题</span>，因此，shell 真的是得学习的一项工具。而且，他可以让您更深入 
		Linux ，更了解他，而不是只会按一按鼠标而已！所谓『天助自助者！』多摸一点文本模式的东西，会让你与
		Linux 更亲近呢！</p>
		<ul class="toplist"><li>Linux 的任督二脉： shell 是也！</li></ul>
		<p>有些朋友也很可爱，常会说：『<span class="text_import2">我学这么多干什么？
		又不常用，也用不到</span>！』嘿嘿！有没有听过『书到用时方恨少？』
		当你的主机一切安然无恙的时候，您当然会觉得好像学这么多的东西一点帮助也没有呀！
		万一，某一天真的不幸给他中标了，您该如何是好？是直接重新安装？
		还是先追踪入侵来源后进行漏洞的修补？或者是干脆就关站好了？这当然涉及很多的考量，
		但就以鸟哥的观点来看，多学一点总是好的，尤其我们可以有备而无患嘛！甚至学的不精也没有关系，了解概念也就
		OK 啦！毕竟没有人要您一定要背这么多的内容啦！了解概念就很了不起了！</p>
		<p>此外，<span class="text_import2">如果你真的有心想要将您的主机管理的好，那么良好的
		shell 程序编写是一定需要的啦</span>！就鸟哥自己来说，鸟哥管理的主机虽然还不算多，
		只有区区不到十部，但是如果每部主机都要花上几十分钟来查阅他的注册表信息以及相关的消息，
		那么鸟哥可能会疯掉！基本上，也太没有效率了！这个时候，如果能够借由 shell 提供的数据流重导向以及管线命令，呵呵！
		那么鸟哥分析登录信息只要花费不到十分钟就可以看完所有的主机之重要信息了！相当的好用呢！</p>
		<p>由于学习 shell 的好处真的是多多啦！所以，如果你是个系统管理员，或者有心想要管理系统的话，那么
		shell 与 shell scripts 这个东西真的有必要看一看！因为他就像『打通任督二脉，任何武功都能随你应用』的说！</p>
	<br></div><br>
	<a id="bash_shells"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.3 系统的合法 shell 与 /etc/shells 功能</h2>
		<p>知道什么是 Shell 之后，那么我们来了解一下 Linux 使用的是哪一个 shell 呢？什么！哪一个？难道说 shell 不就是『一个 shell 吗？』哈哈！那可不！由于早年的
		Unix 年代，发展者众，所以由于 shell 依据发展者的不同就有许多的版本，例如常听到的
		Bourne SHell (sh) 、在 Sun 里头缺省的 C SHell、 商业上常用的 K SHell、,
		还有 TCSH 等等，每一种 Shell 都各有其特点。至于 Linux 使用的这一种版本就称为『
		<span class="text_import2">Bourne Again SHell (简称 bash)</span>  』，这个 Shell 是 
		Bourne Shell 的增强版本，也是基准于 GNU 的架构下发展出来的呦！</p>
		<p>在介绍 shell 的优点之前，先来说一说 shell 的简单历史吧(<a href="0320bash.html#ps2">注2</a>)：第一个流行的
		shell 是由 Steven Bourne 发展出来的，为了纪念他所以就称为 Bourne shell
		，或直接简称为 sh ！而后来另一个广为流传的 shell 是由柏克莱大学的 Bill
		Joy 设计依附于 BSD 版的 Unix 系统中的 shell ，这个 shell 的语法有点类似
		C 语言，所以才得名为 C shell ，简称为 csh ！由于在学术界 Sun 
		主机势力相当的庞大，而 Sun 主要是 BSD 的分支之一，所以 C shell 
		也是另一个很重要而且流传很广的 shell 之一 。</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		由于 Linux 为 C 编程语言撰写的，很多程序员使用 C 来开发软件，因此 C shell 相对的就很热门了。
		另外，还记得我们在<a href="0110whatislinux.html">第一章、Linux 是什么</a>提到的吧？
		Sun 公司的创始人就是 Bill Joy，而 BSD 最早就是 Bill Joy 发展出来的啊。
		</fieldset><br>
		<p>那么目前我们的 Linux (以 CentOS 7.x 为例) 有多少我们可以使用的 shells 呢？
		你可以检查一下 /etc/shells 这个文件，至少就有底下这几个可以用的 shells (鸟哥省略了重复的 shell 了！包括 /bin/sh 等于 /usr/bin/sh 啰！)：</p>
		<ul>
		<li>/bin/sh (已经被 /bin/bash 所取代)</li>
		<li>/bin/bash (就是 Linux 缺省的 shell)</li>
		<li>/bin/tcsh (集成 C Shell ，提供更多的功能)</li>
		<li>/bin/csh (已经被 /bin/tcsh 所取代)</li>
		</ul>
		<p>虽然各家 shell 的功能都差不多，但是在某些语法的下达方面则有所不同，因此建议你还是得要选择某一种 shell 来熟悉一下较佳。
		Linux 缺省就是使用 bash ，所以最初你只要学会 bash 就非常了不起了！ ^_^！
		另外，咦！<span class="text_import2">为什么我们系统上合法的 shell 要写入 /etc/shells 这个文件啊？</span>
		这是因为系统某些服务在运作过程中，会去检查用户能够使用的 shells ，而这些 shell 
		的查找就是借由 /etc/shells 这个文件啰！</p>
		<p>举例来说，某些 FTP 网站会去检查用户的可用 shell ，而如果你不想要让这些用户使用 FTP 
		以外的主机资源时，可能会给予该用户一些怪怪的 shell，让用户无法以其他服务登录主机。
		这个时候，你就得将那些怪怪的 shell 写到 /etc/shells 当中了。举例来说，我们的 CentOS 7.x
		的 /etc/shells 里头就有个 /sbin/nologin 文件的存在，这个就是我们说的怪怪的 shell 啰～</p>
		<p>那么，再想一想，<span class="text_import2">我这个用户什么时候可以取得 shell 来工作呢？还有，
		我这个用户缺省会取得哪一个 shell 啊</span>？还记得我们在<a href="0160startlinux.html#start_cmd">第四章的在终端接口登录linux小节</a>当中提到的登录动作吧？
		当我登录的时候，系统就会给我一个 shell 让我来工作了。
		而这个登录取得的 shell 就记录在 /etc/passwd 这个文件内！这个文件的内容是啥？</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd</span>
root:x:0:0:root:/root:<span class="term_write">/bin/bash</span>
bin:x:1:1:bin:/bin:<span class="term_write">/sbin/nologin</span>
daemon:x:2:2:daemon:/sbin:<span class="term_write">/sbin/nologin</span>
<span class="term_say">.....(底下省略).....</span>
</pre></td></tr></tbody></table>
		<p>如上所示，在每一行的最后一个数据，就是你登录后可以取得的缺省的 shell 啦！那你也会看到， root 是 
		/bin/bash ，不过，系统帐号 bin 与 daemon 等等，就使用那个怪怪的 /sbin/nologin 
		啰～关于用户这部分的内容，我们留在<a href="0410accountmanager.html">第十三章的帐号管理</a>时提供更多的说明。</p>
	<br></div><br>
	<a id="bash_bash"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.4 Bash shell 的功能</h2>
		<p>既然 /bin/bash 是 Linux 缺省的 shell ，那么总是得了解一下这个玩意儿吧！bash 是 GNU 计划中重要的工具软件之一，目前也是
		Linux distributions 的标准 shell 。 bash 主要兼容于 sh ，并且依据一些用户需求而加强的
		shell 版本。不论你使用的是那个 distribution ，你都难逃需要学习 bash 的宿命啦！那么这个
		shell 有什么好处，干嘛 Linux 要使用他作为缺省的 shell 呢？ bash 主要的优点有底下几个：</p>
		<ul class="toplist"><li>命令编修能力 (history)：</li></ul>
		<p>bash 的功能里头，鸟哥个人认为相当棒的一个就是『他能记忆使用过的指令！』
		这功能真的相当的棒！因为我只要在指令列按『上下键』就可以找到前/后一个输入的指令！而在很多
		distribution 里头，缺省的指令记忆功能可以到达 1000 个！也就是说，你曾经下达过的指令几乎都被记录下来了。</p>
		<p>这么多的指令记录在哪里呢？在你的家目录内的 <span class="text_import2">.bash_history</span> 啦！
		不过，需要留意的是，<span class="text_import2">~/.bash_history 记录的是前一次登录以前所运行过的指令，
		而至于这一次登录所运行的指令都被暂存在内存中，当你成功的注销系统后，该指令记忆才会记录到 .bash_history 当中</span>！</p>
		<p>这有什么优点呢？最大的好处就是可以『<span class="text_import2">查找曾经做过的举动</span>！』
		如此可以知道你的运行步骤，那么就可以追踪你曾下达过的指令，以作为调试的重要流程！
		但如此一来也有个烦恼，就是如果被骇客入侵了，那么他只要翻你曾经运行过的指令，
		刚好你的指令又跟系统有关 (例如直接输入 MySQL 的密码在指令列上面)，那你的服务器可就伤脑筋了！
		到底记录指令的数目越多还是越少越好？这部份是见仁见智啦，没有一定的答案的。</p>
		<a id="tab"></a>
		<ul class="toplist"><li>命令与文件补全功能： ([tab] 按键的好处)</li></ul>
		<p>还记得我们在<a href="0160startlinux.html#cmd_hkey">第四章内的重要的几个热键小节</a>当中提到的
		[tab] 这个按键吗？这个按键的功能就是在 bash 里头才有的啦！常常在 bash 环境中使用 [tab] 
		是个很棒的习惯喔！因为至少可以让你 <span class="text_import2">1)少打很多字； 2)确定输入的数据是正确的！</span>
		使用 [tab] 按键的时机依据 [tab] 接在指令后或参数后而有所不同。我们再复习一次：</p>
		<ul class="text_import2">
		<li>[Tab] 接在一串指令的第一个字的后面，则为命令补全；</li>
		<li>[Tab] 接在一串指令的第二个字以后时，则为『文件补齐』！</li>
		<li>若安装 bash-completion 软件，则在某些指令后面使用 [tab] 按键时，可以进行『选项/参数的补齐』功能！</li>
		</ul>
		<p>所以说，如果我想要知道我的环境当中所有以 c 为开头的指令呢？就按下『 c[tab][tab] 』就好啦！ ^_^！
		是的！真的是很方便的功能，所以，<span class="text_import2">有事没事，在
		bash shell 底下，多按几次 [tab] 是一个不错的习惯啦</span>！</p>
		<ul class="toplist"><li>命令别名设置功能： (alias)</li></ul>
		<p>假如我需要知道这个目录底下的所有文件 (包含隐藏档) 及所有的文件属性，那么我就必须要下达『
		ls -al 』这样的指令串，唉！真麻烦，有没有更快的取代方式？呵呵！就使用命令别名呀！例如鸟哥最喜欢直接以
		lm 这个自订的命令来取代上面的命令，也就是说， <span class="text_import2">lm 会等于 ls -al</span>
		这样的一个功能，嘿！那么要如何作呢？就使用 alias 即可！你可以在指令列输入 alias 
		就可以知道目前的命令别名有哪些了！也可以直接下达命令来设置别名呦：</p>
		<ul><li class="text_import2" style="font-family:&#39;细明体&#39;">alias lm='ls -al'</li></ul>
		<ul class="toplist"><li>工作控制、前景背景控制： (job control, foreground, background)</li></ul>
		<p>这部分我们在<a href="0440processcontrol.html">第十六章 Linux 进程控制</a>中再提及！
		使用前、背景的控制可以让工作进行的更为顺利！至于工作控制(jobs)的用途则更广，
		可以让我们随时将工作丢到背景中运行！而不怕不小心使用了
		[Ctrl] + c 来停掉该进程！真是好样的！此外，也可以在单一登录的环境中，达到多任务的目的呢！</p>
		<ul class="toplist"><li>程序化脚本： (shell scripts)</li></ul>
		<p>在 DOS 年代还记得将一堆指令写在一起的所谓的『批次档』吧？在 Linux 底下的
		shell scripts 则发挥更为强大的功能，可以将你平时管理系统常需要下达的连续指令写成一个文件，
		该文件并且可以透过对谈交互式的方式来进行主机的侦测工作！也可以借由
		shell 提供的环境变量及相关指令来进行设计，哇！整个设计下来几乎就是一个小型的编程语言了！该
		scripts 的功能真的是超乎鸟哥的想像之外！以前在 DOS 底下需要编程语言才能写的东西，在
		Linux 底下使用简单的 shell scripts 就可以帮你达成了！真的厉害！这部分我们在<a href="0340bashshell-scripts.html">第十二章</a>再来谈！</p>
		<ul class="toplist"><li>通配符： (Wildcard)</li></ul>
		<p>除了完整的字符串之外， bash 还支持许多的通配符来帮助用户查找与指令下达。
		举例来说，想要知道 /usr/bin 底下有多少以 X 为开头的文件吗？使用：『
		ls -l /usr/bin/X* 』就能够知道啰～此外，还有其他可供利用的通配符，
		这些都能够加快用户的操作呢！</p>
		<p>总之，bash 这么好！不学吗？怎么可能！来学吧！ ^_^</p>
	<br></div><br>
	<a id="bash_type"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.5 查找指令是否为 Bash shell 的内置命令： type</h2>
		<p>我们在<a href="0160startlinux.html">第四章</a>提到关于
		<a href="0160startlinux.html#manual_man">Linux 的在线说明文档</a>部分，也就是 
		man page 的内容，那么 bash 有没有什么说明文档啊？开玩笑～
		这么棒的东西怎么可能没有说明文档！请你在 shell 的环境下，直接输入 man bash 瞧一瞧，
		嘿嘿！不是盖的吧！让你看个几天几夜也无法看完的 bash 说明文档，可是很详尽的数据啊！ ^_^</p>
		<p>不过，在这个 bash 的 man page 当中，不知道你是否有察觉到，咦！
		怎么这个说明文档里面有其他的文件说明啊？举例来说，那个 cd 指令的说明就在这个 man page 内？
		然后我直接输入 man cd 时，怎么出现的画面中，最上方竟然出现一堆指令的介绍？这是怎么回事？
		为了方便 shell 的操作，其实 bash 已经『内置』了很多指令了，例如上面提到的 cd ，
		还有例如 umask 等等的指令，都是内置在 bash 当中的呢！</p>
		<p>那我怎么知道这个指令是来自于外部指令(指的是其他非 bash 所提供的指令) 或是内置在 bash 当中的呢？
		嘿嘿！利用 type 这个指令来观察即可！举例来说：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">type [-tpa] name</span>
<span class="term_say">选项与参数：
    ：不加任何选项与参数时，type 会显示出 name 是外部指令还是 bash 内置指令
-t  ：当加入 -t 参数时，type 会将 name 以底下这些字眼显示出他的意义：
      file    ：表示为外部指令；
      alias   ：表示该指令为命令别名所设置的名称；
      builtin ：表示该指令为 bash 内置的指令功能；
-p  ：如果后面接的 name 为外部指令时，才会显示完整文件名；
-a  ：会由 PATH 变量定义的路径中，将所有含 name 的指令都列出来，包含 alias</span>
<span class="term_hd">范例一：查找一下 ls 这个指令是否为 bash 内置？</span>
[dmtsai@study ~]$ <span class="term_command">type ls</span>
ls is aliased to `ls --color=auto' <span class="term_note">&lt;==未加任何参数，列出 ls 的最主要使用情况</span>
[dmtsai@study ~]$ <span class="term_command">type -t ls</span>
alias                              <span class="term_note">&lt;==仅列出 ls 运行时的依据</span>
[dmtsai@study ~]$ <span class="term_command">type -a ls</span>
ls is aliased to `ls --color=auto' <span class="term_note">&lt;==最先使用 aliase</span>
ls is /usr/bin/ls                  <span class="term_note">&lt;==还有找到外部指令在 /bin/ls</span>
<span class="term_hd">范例二：那么 cd 呢？</span>
[dmtsai@study ~]$ <span class="term_command">type cd</span>
cd is a shell builtin              <span class="term_note">&lt;==看到了吗？ cd 是 shell 内置指令</span>
</pre></td></tr></tbody></table>
		<p>透过 type 这个指令我们可以知道每个指令是否为 bash 的内置指令。
		此外，由于利用 type 搜索后面的名称时，如果后面接的名称并不能以运行档的状态被找到，
		那么该名称是不会被显示出来的。也就是说， type 主要在找出『运行档』而不是一般文件文件名喔！
		呵呵！所以，<span class="text_import2">这个 type 也可以用来作为类似 <a href="0220filemanager.html#which">which</a>
		指令的用途啦！</span>找指令用的！</p>
	<br></div><br>
	<a id="bash_command"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.1.6 指令的下达与快速编辑按钮</h2>
		<p>我们在<a href="0160startlinux.html#cmd_cmd">第四章的开始下达指令小节</a>已经提到过在
		shell 环境下的指令下达方法，如果你忘记了请回到第四章再去回忆一下！这里不重复说明了。
		鸟哥这里仅就反斜线 (\) 来说明一下指令下达的方式啰！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例：如果指令串太长的话，如何使用两行来输出？</span>
[dmtsai@study ~]$ <span class="term_command">cp /var/spool/mail/root /etc/crontab \</span>
&gt; <span class="term_command">/etc/fstab /root</span>
</pre></td></tr></tbody></table>
		<p>上面这个指令用途是将三个文件复制到 /root 这个目录下而已。不过，因为指令太长，
		于是鸟哥就利用『 \[Enter] 』来将 [Enter] 这个按键『跳脱！』开来，让
		[Enter] 按键不再具有『开始运行』的功能！好让指令可以继续在下一行输入。
		<span class="text_import2">需要特别留意， [Enter] 按键是紧接着反斜线 (\) 的，两者中间没有其他字符。
		因为 \ 仅跳脱『紧接着的下一个字符』而已</span>！所以，万一我写成：
		『<span class="text_import2" style="font-family:&#39;细明体&#39;"> \ [Enter]</span> 』，亦即 
		[Enter] 与反斜线中间有一个空格时，则 \ 跳脱的是『空白键』而不是 [Enter] 按键！这个地方请再仔细的看一遍！很重要！</p>
		<p>如果顺利跳脱 [Enter] 后，下一行最前面就会主动出现 &gt; 的符号，
		你可以继续输入指令啰！也就是说，那个 &gt; 是系统自动出现的，你不需要输入。</p>
		<p>另外，当你所需要下达的指令特别长，或者是你输入了一串错误的指令时，你想要快速的将这串指令整个删除掉，一般来说，我们都是按下删除键的。
		有没有其他的快速组合键可以协助呢？是有的！常见的有底下这些：</p>
<table class="news" style="width: 90%">
<tbody><tr class="theader"><td>组合键</td><td>功能与示范</td></tr>
<tr><td>[ctrl]+u/[ctrl]+k</td><td>分别是从光标处向前删除指令串 ([ctrl]+u) 及向后删除指令串 ([ctrl]+k)。</td></tr>
<tr><td>[ctrl]+a/[ctrl]+e</td><td>分别是让光标移动到整个指令串的最前面 ([ctrl]+a) 或最后面 ([ctrl]+e)。</td></tr>
</tbody></table>
		<p>总之，当我们顺利的在终端机 (tty) 上面登录后， Linux 就会依据 /etc/passwd 
		文件的设置给我们一个 shell (缺省是 bash)，然后我们就可以依据上面的指令下达方式来操作 shell，
		之后，我们就可以透过 man 这个在线查找来查找指令的使用方式与参数说明，
		很不错吧！那么我们就赶紧更进一步来操作 bash 这个好玩的东西啰！</p>
	<br></div>
</div>
<a id="variable"></a>
<div class="block1">
<h2>10.2 Shell 的变量功能</h2>
	<p>变量是 bash 环境中非常重要的一个玩意儿，我们知道 Linux 是多人多任务的环境，每个人登录系统都能取得一个 bash shell，
	每个人都能够使用 bash 下达 mail 这个指令来收受『自己』的邮件等等。问题是， bash 是如何得知你的邮件信箱是哪个文件？
	这就需要『变量』的帮助啦！所以，你说变量重不重要呢？底下我们将介绍重要的环境变量、变量的取用与设置等数据，
	呼呼！动动脑时间又来到啰！^_^</p>
	<a id="variable_var"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.1 什么是变量？</h2>
		<p>那么，什么是『变量』呢？简单的说，就是让某一个特定字符串代表不固定的内容就是了。举个大家在国中都会学到的数学例子，
		那就是：『 y = ax + b 』这东西，<span class="text_import2">在等号左边的(y)就是变量，在等号右边的(ax+b)就是变量内容。
		要注意的是，左边是未知数，右边是已知数喔！</span>
		讲的更简单一点，我们可以『<span class="text_import2">用一个简单的 "字眼" 
		来取代另一个比较复杂或者是容易变动的数据</span>』。这有什么好处啊？最大的好处就是『方便！』。</p>
		<ul class="toplist"><li>变量的可变性与方便性</li></ul>
		<a id="mail"></a>
		<p>举例来说，我们每个帐号的邮件信箱缺省是以 MAIL 这个变量来进行访问的，
		当 dmtsai 这个用户登录时，他便会取得 MAIL 这个变量，而这个变量的内容其实就是 /var/spool/mail/dmtsai，
		那如果 vbird 登录呢？他取得的 MAIL 这个变量的内容其实就是 /var/spool/mail/vbird 。
		而我们使用信件读取指令 mail 来读取自己的邮件信箱时，嘿嘿，这支程序可以直接读取 MAIL 这个变量的内容，
		就能够自动的分辨出属于自己的信箱信件啰！这样一来，设计程序的设计师就真的很方便的啦！</p>
	<a id="fig10.2.1"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/var_01.gif" alt="程序、变量与不同用户的关系" title="程序、变量与不同用户的关系" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.2.1、程序、变量与不同用户的关系</div>
		<p>如上图所示，由于系统已经帮我们规划好 MAIL 这个变量，所以用户只要知道 mail 这个指令如何使用即可，
		mail 会主动的取用 MAIL 这个变量，就能够如上图所示的取得自己的邮件信箱了！(注意大小写，小写的 mail 是指令，
		大写的 MAIL 则是变量名称喔！)</p>
		<p>那么使用变量真的比较好吗？这是当然的！想像一个例子，如果 mail 这个指令将 root 收信的邮件信箱 (mailbox) 文件名为
		/var/spool/mail/root 直接写入代码中。那么当 dmtsai 要使用 mail 时，将会取得 /var/spool/mail/root 这个文件的内容！
		不合理吧！所以你就需要帮 dmtsai 也设计一个 mail 的程序，将 /var/spool/mail/dmtsai 写死到 mail 的代码当中！
		天呐！那系统要有多少个 mail 指令啊？反过来说，使用变量就变的很简单了！因为你不需要更动到代码啊！
		只要将 MAIL 这个变量带入不同的内容即可让所有用户透过 mail 取得自己的信件！当然简单多了！</p>
		<ul class="toplist"><li>影响 bash 环境操作的变量</li></ul>
		<p>某些特定变量会影响到 bash 的环境喔！举例来说，我们前面已经提到过很多次的那个 PATH 变量！
		你能不能在任何目录下运行某个指令，与 PATH 这个变量有很大的关系。例如你下达 ls 这个指令时，系统就是透过 PATH 
		这个变量里面的内容所记录的路径顺序来搜索指令的呢！如果在搜索完 PATH 变量内的路径还找不到 ls 这个指令时，
		就会在屏幕上显示『 command not found 』的错误消息了。</p>
		<p>如果说的学理一点，那么由于在 Linux System 下面，所有的线程都是需要一个运行码，
		而就如同上面提到的，你『<span class="text_import2">真正以
		shell 来跟 Linux 沟通，是在正确的登录 Linux 之后！</span>』这个时候你就有一个
		bash 的运行进程，也才可以真正的经由 bash 来跟系统沟通啰！而在进入 shell
		之前，也正如同上面提到的，由于系统需要一些变量来提供他数据的访问 (或者是一些环境的设置参数值，
		例如是否要显示彩色等等的) ，所以就有一些所谓的『<span class="text_import2">环境变量</span>』
		需要来读入系统中了！这些环境变量例如 PATH、HOME、MAIL、SHELL 等等，都是很重要的，
		为了区别与自订变量的不同，环境变量通常以大写字符来表示呢！</p>
		<ul class="toplist"><li>脚本编程 (shell script) 的好帮手</li></ul>
		<p>这些还都只是系统缺省的变量的目的，如果是个人的设置方面的应用呢：例如你要写一个大型的
		script 时，有些数据因为可能由于用户习惯的不同而有差异，比如说路径好了，由于该路径在
		script 被使用在相当多的地方，如果下次换了一部主机，都要修改 script 里面的所有路径，那么我一定会疯掉！
		这个时候如果使用变量，而将该变量的定义写在最前面，后面相关的路径名称都以变量来取代，
		嘿嘿！那么你只要修改一行就等于修改整篇 script 了！方便的很！所以，良好的程序员都会善用变量的定义！</p>
	<a id="fig10.2.2"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/var_02.gif" alt="变量应用于 shell script 的示意图" title="变量应用于 shell script 的示意图" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.2.2、变量应用于 shell script 的示意图</div>
		<p>最后我们就简单的对『<span class="text_import2">什么是变量</span>』作个简单定义好了：
		『<span class="text_import2">变量就是以一组文本或符号等，来取代一些设置或者是一串保留的数据！</span>』，
		例如：我设置了『myname』就是『VBird』，所以当你读取
		myname 这个变量的时候，系统自然就会知道！哈！那就是 VBird 啦！
		那么如何『<span class="text_import2">显示变量</span>』呢？这就需要使用到 echo 这个指令啦！</p>
	<br></div><br>
	<a id="variable_echo"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.2 变量的取用与设置：echo, 变量设置规则, unset</h2>
		<p>说的口沫横飞的，也不知道『变量』与『变量代表的内容』有啥关系？
		那我们就将『变量』的『内容』拿出来给您瞧瞧好了。你可以利用 echo 这个指令来取用变量，
		但是，变量在被取用时，前面必须要加上钱字号『 $ 』才行，举例来说，要知道 PATH 的内容，该如何是好？</p>
		<a id="echo"></a>
		<ul class="toplist"><li>变量的取用: echo</li></ul>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo $variable</span>
[dmtsai@study ~]$ <span class="term_command">echo $PATH</span>
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
[dmtsai@study ~]$ <span class="term_command">echo ${PATH}</span>  <span class="term_note"># 近年来，鸟哥比较偏向使用这种格式喔！</span>
</pre></td></tr></tbody></table>
		<p>变量的取用就如同上面的范例，利用 echo 就能够读出，只是需要在变量名称前面加上 $ ，
		或者是以 ${变量} 的方式来取用都可以！当然啦，那个 echo 的功能可是很多的，
		我们这里单纯是拿 echo 来读出变量的内容而已，更多的 echo 使用，请自行给他 man echo 吧！ ^_^</p>
<table class="exam"><tbody><tr><td>
例题：<div>
请在屏幕上面显示出您的环境变量 HOME 与 MAIL：
</div>
答：<div>
<span class="text_import2" style="font-family:&#39;细明体&#39;">echo $HOME 或者是 echo ${HOME}<br>echo $MAIL 或者是 echo ${MAIL}</span>
</div>
</td></tr></tbody></table>
		<p>现在我们知道了变量与变量内容之间的相关性了，好了，那么我要如何『设置』或者是『修改』
		某个变量的内容啊？很简单啦！用『等号(=)』连接变量与他的内容就好啦！举例来说：
		我要将 myname 这个变量名称的内容设置为 VBird ，那么：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo ${myname}</span>
       <span class="term_note">&lt;==这里并没有任何数据～因为这个变量尚未被设置！是空的！</span>
[dmtsai@study ~]$ <span class="term_command">myname=VBird</span>
[dmtsai@study ~]$ <span class="term_command">echo ${myname}</span>
VBird  <span class="term_note">&lt;==出现了！因为这个变量已经被设置了！</span>
</pre></td></tr></tbody></table>
		<p>瞧！如此一来，这个变量名称 myname 的内容就带有 VBird 这个数据啰～
		而由上面的例子当中，我们也可以知道：
		<span class="text_import2">在 bash 当中，当一个变量名称尚未被设置时，缺省的内容是『空』的</span>。
		另外，变量在设置时，还是需要符合某些规定的，否则会设置失败喔！这些规则如下所示啊！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		要请各位读者注意喔，每一种 shell 的语法都不相同～在变量的使用上，bash 在你没有设置的变量中强迫去 echo 时，它会显示出空的值。
		在其他某些 shell 中，随便去 echo 一个不存在的变量，它是会出现错误消息的喔！要注意！要注意！
		</fieldset><br>
		<a id="variable_rule"></a>
		<ul class="toplist"><li>变量的设置规则</li></ul>
		<ol style="font-family:&#39;细明体&#39;">
		<li><span class="text_import2">变量与变量内容以一个等号『=』来链接</span>，如下所示：
			<br>『myname=VBird』<br><br></li>
		<li><span class="text_import2">等号两边不能直接接空白字符</span>，如下所示为错误：
			<br>『myname = VBird』或『myname=VBird Tsai』<br><br></li>
		<li>变量名称只能是英文本母与数字，但是<span class="text_import2">开头字符不能是数字</span>，如下为错误：
			<br>『2myname=VBird』<br><br></li>
		<li>变量内容若有空白字符可使用双引号『"』或单引号『'』将变量内容结合起来，但
			<ul style="padding-left: 15px">
			<li><span class="text_import2">双引号内的特殊字符如 $ 等，可以保有原本的特性</span>，如下所示：<br>
			『var="lang is $LANG"』则『echo $var』可得『lang is zh_TW.UTF-8』</li>
			<li><span class="text_import2">单引号内的特殊字符则仅为一般字符 (纯文本)</span>，如下所示：<br>
			『var='lang is $LANG'』则『echo $var』可得『lang is $LANG』</li>
			</ul><br></li>
		<li>可用<span class="text_import2">跳脱字符『 \ 』</span>将特殊符号(如 [Enter], $, \, 空白字符, 
			'等)变成一般字符，如：<br>
			『myname=VBird\ Tsai』<br><br></li>
		<li>在一串指令的运行中，还需要借由其他额外的指令所提供的信息时，可以<span class="text_import2">使用反单引号『`指令`』或
			『$(指令)』</span>。特别注意，那个 ` 是键盘上方的数字键 1 左边那个按键，而不是单引号！
			例如想要取得核心版本的设置：<br>『version=$(uname -r)』再『echo 
			$version』可得『3.10.0-229.el7.x86_64』<br><br></li>
		<li>若该变量为扩增变量内容时，则可用 "$变量名称" 或 ${变量} 累加内容，如下所示：<br>
			『PATH="$PATH":/home/bin』或『PATH=${PATH}:/home/bin』<br><br></li>
		<li>若该变量需要在其他子进程运行，则<span class="text_import2">需要以 export 来使变量变成环境变量</span>：<br>
			『export PATH』<br><br></li>
		<li>通常大写字符为系统缺省变量，自行设置变量可以使用小写字符，方便判断 (纯粹依照用户兴趣与嗜好) ；<br><br></li>
		<li><a id="unset"></a><span class="text_import2">取消变量的方法为使用 unset</span> ：『unset 
			变量名称』例如取消 myname 的设置：<br>
			『unset myname』</li>
		</ol>
		<p>底下让鸟哥举几个例子来让你试看看，就知道怎么设置好你的变量啰！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：设置一变量 name ，且内容为 VBird</span>
[dmtsai@study ~]$ <span class="term_command">12name=VBird</span>
bash: 12name=VBird: command not found...  <span class="term_note">&lt;==屏幕会显示错误！因为不能以数字开头！</span>
[dmtsai@study ~]$ <span class="term_command">name = VBird</span>            <span class="term_note">&lt;==还是错误！因为有空白！</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird</span>              <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_hd">范例二：承上题，若变量内容为 VBird's name 呢，就是变量内容含有特殊符号时：</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird's name</span>  
<span class="term_say"># <u>单引号与双引号必须要成对</u>，在上面的设置中仅有一个单引号，因此当你按下 enter 后，
# 你还可以继续输入变量内容。这与我们所需要的功能不同，失败啦！
# 记得，失败后要复原请按下 [ctrl]-c 结束！</span>
[dmtsai@study ~]$ <span class="term_command">name="VBird's name"</span>    <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 指令是由左边向右找→，先遇到的引号先有用，因此如上所示， 单引号变成一般字符！</span>
[dmtsai@study ~]$ <span class="term_command">name='VBird's name'</span>    <span class="term_note">&lt;==失败的啦！</span>
<span class="term_say"># 因为前两个单引号已成对，后面就多了一个不成对的单引号了！因此也就失败了！</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird\'s\ name</span>     <span class="term_note">&lt;==OK 的啦！</span>
<span class="term_say"># 利用反斜线 (\) 跳脱特殊字符，例如单引号与空白键，这也是 OK 的啦！</span>
<span class="term_hd">范例三：我要在 PATH 这个变量当中『累加』:/home/dmtsai/bin 这个目录</span>
[dmtsai@study ~]$ <span class="term_command">PATH=$PATH:/home/dmtsai/bin</span>
[dmtsai@study ~]$ <span class="term_command">PATH="$PATH":/home/dmtsai/bin</span>
[dmtsai@study ~]$ <span class="term_command">PATH=${PATH}:/home/dmtsai/bin</span>
<span class="term_say"># 上面这三种格式在 PATH 里头的设置都是 OK 的！但是底下的例子就不见得啰！</span>
<span class="term_hd">范例四：承范例三，我要将 name 的内容多出 "yes" 呢？</span>
[dmtsai@study ~]$ <span class="term_command">name=$nameyes</span>  
<span class="term_say"># 知道了吧？如果没有双引号，那么变量成了啥？name 的内容是 $nameyes 这个变量！
# 呵呵！我们可没有设置过 nameyes 这个变量呐！所以，应该是底下这样才对！</span>
[dmtsai@study ~]$ <span class="term_command">name="$name"yes</span>
[dmtsai@study ~]$ <span class="term_command">name=${name}yes</span>  <span class="term_note">&lt;==以此例较佳！</span>
<span class="term_hd">范例五：如何让我刚刚设置的 name=VBird 可以用在下个 shell 的进程？</span>
[dmtsai@study ~]$ <span class="term_command">name=VBird</span>
[dmtsai@study ~]$ <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子进程</span>
[dmtsai@study ~]$ <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子进程：再次的 echo 一下；</span>
       <span class="term_note">&lt;==嘿嘿！并没有刚刚设置的内容喔！</span>
[dmtsai@study ~]$ <span class="term_command">exit      </span>  <span class="term_note">&lt;==子进程：离开这个子进程</span>
[dmtsai@study ~]$ <span class="term_command">export name</span>
[dmtsai@study ~]$ <span class="term_command">bash      </span>  <span class="term_note">&lt;==进入到所谓的子进程</span>
[dmtsai@study ~]$ <span class="term_command">echo $name</span>  <span class="term_note">&lt;==子进程：在此运行！</span>
VBird  <span class="term_note">&lt;==看吧！出现设置值了！</span>
[dmtsai@study ~]$ <span class="term_command">exit      </span>  <span class="term_note">&lt;==子进程：离开这个子进程</span>
</pre></td></tr></tbody></table>
		<p>什么是『子进程』呢？就是说，在我目前这个 shell 的情况下，去启用另一个新的 shell ，新的那个 shell 
		就是子进程啦！在一般的状态下，父进程的自订变量是无法在子进程内使用的。但是透过 export 
		将变量变成环境变量后，就能够在子进程底下应用了！很不赖吧！至于进程的相关概念，
		我们会在<a href="0440processcontrol.html">第十六章进程管理</a>当中提到的喔！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：如何进入到您目前核心的模块目录？</span>
[dmtsai@study ~]$ <span class="term_command">cd /lib/modules/`uname -r`/kernel</span>
[dmtsai@study ~]$ <span class="term_command">cd /lib/modules/$(uname -r)/kernel</span>  <span class="term_note"># 以此例较佳！</span>
</pre></td></tr></tbody></table>
		<p>每个 Linux 都能够拥有多个核心版本，且几乎 distribution 的核心版本都不相同。以 CentOS 7.1 (未更新前) 
		为例，他的缺省核心版本是 3.10.0-229.el7.x86_64 ，所以核心模块目录在 /lib/modules/3.10.0-229.el7.x86_64/kernel/ 内。
		也由于每个 distributions 的这个值都不相同，但是我们却可以利用 uname -r 
		这个指令先取得版本信息。所以啰，就可以透过上面指令当中的内含指令 $(uname -r)
		先取得版本输出到 cd ... 那个指令当中，就能够顺利的进入目前核心的驱动程序所放置的目录啰！很方便吧！</p>
		<p>其实上面的指令可以说是作了两次动作，亦即是：</p>
		<ol>
		<li>先进行反单引号内的动作『uname -r』并得到核心版本为 3.10.0-229.el7.x86_64</li>
		<li>将上述的结果带入原指令，故得指令为：『cd /lib/modules/3.10.0-229.el7.x86_64/kernel/』</li>
		</ol>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		为什么鸟哥比较建议记忆 $( command ) 呢？还记得小时候学数学的加减乘除，我们都知道得要先乘除后加减。那如果硬要先加减再乘除呢？
		当然就是加上括号 () 来处理即可啊！所以啰，这个指令的处理方式也差不多，只是括号左边得要加个钱字号就是了！
		</fieldset><br>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例七：取消刚刚设置的 name 这个变量内容</span>
[dmtsai@study ~]$ <span class="term_command">unset name</span>
</pre></td></tr></tbody></table>
		<p>根据上面的案例你可以试试看！就可以了解变量的设置啰！这个是很重要的呦！请勤加练习！
		其中，较为重要的一些特殊符号的使用啰！例如单引号、双引号、跳脱字符、钱字号、反单引号等等，底下的例题想一想吧！</p>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
在变量的设置当中，单引号与双引号的用途有何不同？<br>
</div>
答：<div>
单引号与双引号的最大不同在于<span class="text_import2">双引号仍然可以保有变量的内容，但单引号内仅能是一般字符
，而不会有特殊符号。</span>我们以底下的例子做说明：假设您定义了一个变量， name=VBird ，现在想以 
name 这个变量的内容定义出 myname 显示 VBird its me 这个内容，要如何订定呢？
<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
[dmtsai@study ~]$ name=VBird<br>
[dmtsai@study ~]$ echo $name<br>
VBird<br>
[dmtsai@study ~]$ myname="$name its me"<br>
[dmtsai@study ~]$ echo $myname<br>
VBird its me<br>
[dmtsai@study ~]$ myname='$name its me'<br>
[dmtsai@study ~]$ echo $myname<br>
$name its me</blockquote>
发现了吗？没错！使用了单引号的时候，那么 $name 将失去原有的变量内容，仅为一般字符的显示型态而已！这里必需要特别小心在意！
</div>
</td></tr></tbody></table><br>
<table class="exam" style="width:90%"><tbody><tr><td>
例题：<div>
在指令下达的过程中，反单引号( ` )这个符号代表的意义为何？
</div>
答：<div>
在一串指令中，在 ` 之内的指令将会被先运行，而其运行出来的结果将做为外部的输入信息！例如 
uname -r 会显示出目前的核心版本，而我们的核心版本在 /lib/modules 里面，因此，你可以先运行 
uname -r 找出核心版本，然后再以『 cd 目录』到该目录下，当然也可以运行如同上面范例六的运行内容啰。
<br><br>另外再举个例子，我们也知道， <a href="0220filemanager.html#locate">locate</a>
指令可以列出所有的相关文件文件名，但是，如果我想要知道各个文件的权限呢？举例来说，我想要知道每个 crontab 相关文件名的权限：
<blockquote style="font-family:&#39;细明体&#39;" class="text_import2">
[dmtsai@study ~]$ ls -ld `locate crontab`<br>
[dmtsai@study ~]$ ls -ld $(locate crontab)</blockquote>
如此一来，先以 locate 将文件名数据都列出来，再以 ls 指令来处理的意思啦！瞭了吗？ ^_^
</div>
</td></tr></tbody></table><br>
<table class="exam" style="width:90%"><tbody><tr><td>
例题：<div>
若你有一个常去的工作目录名称为：『/cluster/server/work/taiwan_2015/003/』，如何进行该目录的简化？
</div>
答：<div>
在一般的情况下，如果你想要进入上述的目录得要『cd /cluster/server/work/taiwan_2015/003/』，
以鸟哥自己的案例来说，鸟哥跑数值模式常常会设置很长的目录名称(避免忘记)，但如此一来变换目录就很麻烦。
此时，鸟哥习惯利用底下的方式来降低指令下达错误的问题：<blockquote style="font-family:&#39;细明体&#39;" class="text_import2">
[dmtsai@study ~]$ work="/cluster/server/work/taiwan_2015/003/"<br>
[dmtsai@study ~]$ cd $work</blockquote>
未来我想要使用其他目录作为我的模式工作目录时，只要变更 work 这个变量即可！而这个变量又可以在 <a href="0320bash.html#settings_bashrc">bash
的设置档</a>(~/.bashrc)中直接指定，那我每次登录只要运行『 cd $work 』就能够去到数值模式仿真的工作目录了！是否很方便呢？ ^_^
</div>
</td></tr></tbody></table><br>
	<br></div><br>
	<a id="variable_environ"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.3 环境变量的功能</h2>
		<p>环境变量可以帮我们达到很多功能～包括家目录的变换啊、提示字符的显示啊、运行档搜索的路径啊等等的，
		还有很多很多啦！那么，既然环境变量有那么多的功能，问一下，目前我的 shell 环境中，
		有多少缺省的环境变量啊？我们可以利用两个指令来查阅，分别是 env 与 export 呢！</p>
		<a id="env"></a>
		<ul class="toplist"><li>用 env 观察环境变量与常见环境变量说明</li></ul>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：列出目前的 shell 环境下的所有环境变量与其内容。</span>
[dmtsai@study ~]$ <span class="term_command">env</span>
HOSTNAME=study.centos.vbird    <span class="term_note">&lt;== 这部主机的主机名称</span>
TERM=xterm                     <span class="term_note">&lt;== 这个终端机使用的环境是什么类型</span>
SHELL=/bin/bash                <span class="term_note">&lt;== 目前这个环境下，使用的 Shell 是哪一个程序？</span>
HISTSIZE=1000                  <span class="term_note">&lt;== 『记录指令的笔数』在 CentOS 缺省可记录 1000 笔</span>
OLDPWD=/home/dmtsai            <span class="term_note">&lt;== 上一个工作目录的所在</span>
LC_ALL=en_US.utf8              <span class="term_note">&lt;== 由于语系的关系，鸟哥偷偷丢上来的一个设置</span>
USER=dmtsai                    <span class="term_note">&lt;== 用户的名称啊！</span>
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:
or=40;31;01:mi=01;05;37;41:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:
*.tar=01...                    <span class="term_note">&lt;== 一些颜色显示</span>
MAIL=/var/spool/mail/dmtsai    <span class="term_note">&lt;== 这个用户所取用的 mailbox 位置</span>
PATH=/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
PWD=/home/dmtsai               <span class="term_note">&lt;== 目前用户所在的工作目录 (利用 pwd 取出！)</span>
LANG=zh_TW.UTF-8               <span class="term_note">&lt;== 这个与语系有关，底下会再介绍！</span>
HOME=/home/dmtsai              <span class="term_note">&lt;== 这个用户的家目录啊！</span>
LOGNAME=dmtsai                 <span class="term_note">&lt;== 登录者用来登录的帐号名称</span>
_=/usr/bin/env                 <span class="term_note">&lt;== 上一次使用的指令的最后一个参数(或指令本身)</span>
</pre></td></tr></tbody></table>
		<p>env 是 environment (环境) 的简写啊，上面的例子当中，是列出来所有的环境变量。当然，如果使用 export 也会是一样的内容～
		只不过， export 还有其他额外的功能就是了，我们等一下再提这个 export 指令。
		那么上面这些变量有些什么功用呢？<a id="variable_environ_im"></a>底下我们就一个一个来分析分析！</p>
		<ul style="padding-left: 25px">
		<li><span class="text_import1">HOME</span><br>代表用户的家目录。还记得我们可以使用 cd ~ 
			去到自己的家目录吗？或者利用 cd 就可以直接回到用户家目录了。那就是取用这个变量啦～
			有很多程序都可能会取用到这个变量的值！<br><br></li>
		<li><span class="text_import1">SHELL</span><br>告知我们，目前这个环境使用的 SHELL 是哪支程序？
			Linux 缺省使用 /bin/bash 的啦！<br><br></li>
		<li><span class="text_import1">HISTSIZE</span><br>这个与『历史命令』有关，亦即是，
			我们曾经下达过的指令可以被系统记录下来，而记录的『笔数』则是由这个值来设置的。<br><br></li>
		<li><span class="text_import1">MAIL</span><br>当我们使用 mail 这个指令在收信时，系统会去读取的邮件信箱文件 
			(mailbox)。<br><br></li>
		<li><span class="text_import1">PATH</span><br>就是运行档搜索的路径啦～目录与目录中间以冒号(:)分隔，
			由于文件的搜索是依序由 PATH 的变量内的目录来查找，所以，目录的顺序也是重要的喔。<br><br></li>
		<li><span class="text_import1">LANG</span><br>这个重要！就是语系数据啰～很多消息都会用到他，
			举例来说，当我们在启动某些 perl 的编程语言文件时，他会主动的去分析语系数据文件，
			如果发现有他无法解析的编码语系，可能会产生错误喔！一般来说，我们中文编码通常是 zh_TW.Big5 或者是 
			zh_TW.UTF-8，这两个编码偏偏不容易被解译出来，所以，有的时候，可能需要修订一下语系数据。
			这部分我们会在下个小节做介绍的！<br><br></li>
		<li><span class="text_import1">RANDOM</span><br>这个玩意儿就是『随机乱数』的变量啦！目前大多数的
			distributions 都会有乱数产生器，那就是<span class="text_import2"> /dev/random</span> 这个文件。
			我们可以透过这个乱数文件相关的变量 ($RANDOM) 来随机取得乱数值喔。在 BASH 的环境下，这个 RANDOM 
			变量的内容，介于 0~32767 之间，所以，你只要 echo $RANDOM 时，系统就会主动的随机取出一个介于
			0~32767 的数值。万一我想要使用 0~9 之间的数值呢？呵呵～利用 declare 声明数值类型，
			然后这样做就可以了：<br>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">declare -i number=$RANDOM*10/32768 ; echo $number</span>
8   <span class="term_note">&lt;== 此时会随机取出 0~9 之间的数值喔！</span>
</pre></td></tr></tbody></table></li>
		</ul>
		<p>大致上是有这些环境变量啦～里面有些比较重要的参数，在底下我们都会另外进行一些说明的～</p>
		<a id="set"></a>
		<ul class="toplist"><li>用 set 观察所有变量 (含环境变量与自订变量)</li></ul>
		<p>bash 可不只有环境变量喔，还有一些与 bash 操作接口有关的变量，以及用户自己定义的变量存在的。
		那么这些变量如何观察呢？这个时候就得要使用 set 这个指令了。  set 除了环境变量之外，
		还会将其他在 bash 内的变量通通显示出来哩！信息很多，底下鸟哥仅列出几个重要的内容：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">set</span>
BASH=/bin/bash                        <span class="term_note">&lt;== bash 的主程序放置路径</span>
BASH_VERSINFO=([0]="4" [1]="2" [2]="46" [3]="1" [4]="release" [5]="x86_64-redhat-linux-gnu")
BASH_VERSION='4.2.46(1)-release'      <span class="term_note">&lt;== 这两行是 bash 的版本啊！</span>
COLUMNS=90                            <span class="term_note">&lt;== 在目前的终端机环境下，使用的字段有几个字符长度</span>
<span class="term_write">HISTFILE=/home/dmtsai/.bash_history</span>   <span class="term_note">&lt;== 历史命令记录的放置文件，隐藏档</span>
HISTFILESIZE=1000                     <span class="term_note">&lt;== 存起来(与上个变量有关)的文件之指令的最大纪录笔数。</span>
HISTSIZE=1000                         <span class="term_note">&lt;== 目前环境下，内存中记录的历史命令最大笔数。</span>
IFS=$' \t\n'                          <span class="term_note">&lt;== 缺省的分隔符号</span>
LINES=20                              <span class="term_note">&lt;== 目前的终端机下的最大行数</span>
MACHTYPE=x86_64-redhat-linux-gnu      <span class="term_note">&lt;== 安装的机器类型</span>
OSTYPE=linux-gnu                      <span class="term_note">&lt;== 操作系统的类型！</span>
<span class="term_write">PS1='[\u@\h \W]\$ '</span>                   <span class="term_note">&lt;== PS1 就厉害了。这个是命令提示字符，也就是我们常见的
                                          [root@www ~]# 或 [dmtsai ~]$ 的设置值啦！可以更动的！</span>
<span class="term_write">PS2='&gt; '</span>                              <span class="term_note">&lt;== 如果你使用跳脱符号 (\) 第二行以后的提示字符也</span>
<span class="term_write">$</span>                                     <span class="term_note">&lt;== 目前这个 shell 所使用的 PID</span>
<span class="term_write">?</span>                                     <span class="term_note">&lt;== 刚刚运行完指令的回传值。</span>
...
<span class="term_say"># 有许多可以使用的函数库功能被鸟哥取消啰！请自行查阅！</span>
</pre></td></tr></tbody></table>
		<p>一般来说，不论是否为环境变量，只要跟我们目前这个 shell 的操作接口有关的变量，
		通常都会被设置为大写字符，也就是说，『<span class="text_import2">基本上，在 Linux 
		缺省的情况中，使用{大写的字母}来设置的变量一般为系统内定需要的变量</span>』。
		OK！OK！那么上头那些变量当中，有哪些是比较重要的？大概有这几个吧！</p>
		<div class="illus">
		<ul><li>PS1：(提示字符的设置)</li></ul>
			<p>这是 PS1 (数字的 1 不是英文本母)，这个东西就是我们的『<span class="text_import2">命令提示字符</span>』喔！
			当我们每次按下 [Enter] 按键去运行某个指令后，最后要再次出现提示字符时，
			就会主动去读取这个变量值了。上头 PS1 内显示的是一些特殊符号，这些特殊符号可以显示不同的信息，
			每个 distributions 的 bash 缺省的 PS1 变量内容可能有些许的差异，不要紧，『习惯你自己的习惯』就好了。
			你可以用 man bash (<a href="0320bash.html#ps3">注3</a>)去查找一下 PS1 的相关说明，以理解底下的一些符号意义。</p>
			<ul style="font-family: &#39;细明体&#39;; padding-left: 30px; list-style-type: square">
			<li>\d ：可显示出『星期 月 日』的日期格式，如："Mon Feb 2"</li>
			<li>\H ：完整的主机名称。举例来说，鸟哥的练习机为『study.centos.vbird』</li>
			<li>\h ：仅取主机名称在第一个小数点之前的名字，如鸟哥主机则为『study』后面省略</li>
			<li>\t ：显示时间，为 24 小时格式的『HH:MM:SS』</li>
			<li>\T ：显示时间，为 12 小时格式的『HH:MM:SS』</li>
			<li>\A ：显示时间，为 24 小时格式的『HH:MM』</li>
			<li>\@ ：显示时间，为 12 小时格式的『am/pm』样式</li>
			<li>\u ：目前用户的帐号名称，如『dmtsai』；</li>
			<li>\v ：BASH 的版本信息，如鸟哥的测试主机版本为 4.2.46(1)-release，仅取『4.2』显示</li>
			<li>\w ：完整的工作目录名称，由根目录写起的目录名称。但家目录会以 ~ 取代；</li>
			<li>\W ：利用 basename 函数取得工作目录名称，所以仅会列出最后一个目录名。</li>
			<li>\# ：下达的第几个指令。</li>
			<li>\$ ：提示字符，如果是 root 时，提示字符为 # ，否则就是 $ 啰～</li>
			</ul>
			<p>好了，让我们来看看 CentOS 缺省的 PS1 内容吧：『[\u@\h \W]\$ 』，现在你知道那些反斜线后的数据意义了吧？
			要注意喔！那个反斜线后的数据为 PS1 的特殊功能，与 bash 的变量设置没关系啦！不要搞混了喔！
			那你现在知道为何你的命令提示字符是：『 [dmtsai@study ~]$ 』了吧？好了，那么假设我想要有类似底下的提示字符：</p>
			<blockquote class="text_import2">
			[dmtsai@study /home/dmtsai 16:50 #12]$ </blockquote>
			那个 # 代表第 12 次下达的指令。那么应该如何设置 PS1 呢？可以这样啊：<br>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cd /home</span>
[dmtsai@study home]$ <span class="term_command">PS1='[\u@\h \w \A #\#]\$ '</span>
[dmtsai@study /home 17:02 #85]$
<span class="term_say"># 看到了吗？提示字符变了！变的很有趣吧！其中，那个 #85 比较有趣，
# 如果您再随便输入几次 ls 后，该数字就会增加喔！为啥？上面有说明滴！</span>
</pre></td></tr></tbody></table>
		<ul><li>$：(关于本 shell 的 PID)</li></ul>
			<p>钱字号本身也是个变量喔！这个咚咚代表的是『目前这个 Shell 的线程代号』，亦即是所谓的 PID (Process ID)。
			更多的进程观念，我们会在第四篇的时候提及。想要知道我们的 shell 的 PID ，就可以用：『
			echo $$ 』即可！出现的数字就是你的 PID 号码。</p>
		<a id="returnvar"></a><ul><li>?：(关于上个运行指令的回传值)</li></ul>
			<p>虾密？问号也是一个特殊的变量？没错！在 bash 里面这个变量可重要的很！
			这个变量是：『<span class="text_import2">上一个运行的指令所回传的值</span>』，
			上面这句话的重点是『上一个指令』与『回传值』两个地方。<span class="text_import2">当我们运行某些指令时，
			这些指令都会回传一个运行后的代码。一般来说，如果成功的运行该指令，
			则会回传一个 0 值</span>，如果运行过程发生错误，就会回传『错误代码』才对！一般就是以非为 0 的数值来取代。
			我们以底下的例子来看看：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo $SHELL</span>
/bin/bash                                  <span class="term_note">&lt;==可顺利显示！没有错误！</span>
[dmtsai@study ~]$ <span class="term_command">echo $?</span>
0                                          <span class="term_note">&lt;==因为没问题，所以回传值为 0</span>
[dmtsai@study ~]$ <span class="term_command">12name=VBird</span>
bash: 12name=VBird: command not found...   <span class="term_note">&lt;==发生错误了！bash回报有问题</span>
[dmtsai@study ~]$ <span class="term_command">echo $?</span>
127                                        <span class="term_note">&lt;==因为有问题，回传错误代码(非为0)</span>
<span class="term_say"># 错误代码回传值依据软件而有不同，我们可以利用这个代码来搜索错误的原因喔！</span>
[dmtsai@study ~]$ <span class="term_command">echo $?</span>
0
<span class="term_say"># 咦！怎么又变成正确了？这是因为 "?" 只与『上一个运行指令』有关，
# 所以，我们上一个指令是运行『 echo $? 』，当然没有错误，所以是 0 没错！</span>
</pre></td></tr></tbody></table>
		<ul><li>OSTYPE, HOSTTYPE, MACHTYPE：(主机硬件与核心的等级)</li></ul>
			<p>我们在<a href="0105computers.html#pc_cpu">第零章、计算机概论内的 CPU 等级</a>说明中谈过 CPU ，
			目前个人电脑的 CPU 主要分为 32/64 比特，其中 32 比特又可分为 i386, i586, i686，而 64 比特则称为 x86_64。
			由于不同等级的 CPU 指令集不太相同，因此你的软件可能会针对某些 CPU 进行最佳化，以求取较佳的软件性能。
			所以软件就有 i386, i686 及 x86_64 之分。以目前 (2015) 的主流硬件来说，几乎都是 x86_64 的天下！
			因此 CentOS 7 开始，已经不支持 i386 兼容模式的安装光盘了～哇呜！进步的太快了！</p>
			<p>要留意的是，较高端的硬件通常会向下兼容旧有的软件，但较高端的软件可能无法在旧机器上面安装！
			我们在<a href="0130designlinux.html#beforeinstall_distro">第二章</a>就曾说明过，
			这里再强调一次，你可以在 x86_64 的硬件上安装 i386 的 Linux 操作系统，但是你无法在 i686 的硬件上安装
			x86_64 的 Linux 操作系统！这点得要牢记在心！</p>
		</div>
		<a id="export"></a>
		<ul class="toplist"><li>export： 自订变量转成环境变量</li></ul>
		<p>谈了 env 与 set 现在知道有所谓的环境变量与自订变量，那么这两者之间有啥差异呢？其实这两者的差异在于『
		<span class="text_import2">该变量是否会被子进程所继续引用</span>』啦！唔！那么啥是父进程？子进程？
		这就得要了解一下指令的下达行为了。</p>
		<p>当你登录 Linux 并取得一个 bash 之后，你的 bash 就是一个独立的进程，这个进程的识别使用的是一个称为进程识别码，被称为 PID 的就是。
		接下来你在这个 bash 底下所下达的任何指令都是由这个 bash 所衍生出来的，那些被下达的指令就被称为子进程了。
		我们可以用底下的图标来简单的说明一下父进程与子进程的概念：</p>
	<a id="fig10.2.3"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/ppid.gif" alt="进程相关性示意图" title="进程相关性示意图" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.2.3、进程相关性示意图</div>
		<p>如上所示，我们在原本的 bash 底下运行另一个 bash ，结果操作的环境接口会跑到第二个 bash 去(就是子进程)，
		那原本的 bash 就会在暂停的情况 (睡着了，就是 sleep)。整个指令运作的环境是实线的部分！若要回到原本的 bash 去，
		就只有将第二个 bash 结束掉 (下达 exit 或 logout) 才行。更多的进程概念我们会在第四篇谈及，这里只要有这个概念即可。</p>
		<p>这个进程概念与变量有啥关系啊？关系可大了！因为<span class="text_import2">子进程仅会继承父进程的环境变量，
		子进程不会继承父进程的自订变量</span>啦！所以你在原本 bash 的自订变量在进入了子进程后就会消失不见，
		一直到你离开子进程并回到原本的父进程后，这个变量才会又出现！</p>
		<p>换个角度来想，也就是说，如果我能将自订变量变成环境变量的话，那不就可以让该变量值继续存在于子进程了？
		呵呵！没错！此时，那个 export 指令就很有用啦！如你想要让该变量内容继续的在子进程中使用，那么就请运行：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">export 变量名称</span>
</pre></td></tr></tbody></table>
		<p>这东西用在『<span class="text_import2">分享自己的变量设置给后来调用的文件或其他进程</span>』啦！
		像鸟哥常常在自己的主文件后面调用其他附属文件(类似函数的功能)，但是主文件与附属文件内都有相同的变量名称，
		若一再重复设置时，要修改也很麻烦，此时只要在原本的第一个文件内设置好『 export 变量 』，
		后面所调用的文件就能够使用这个变量设置了！而不需要重复设置，这非常实用于 shell script 当中喔！
		如果仅下达 export 而没有接变量时，那么此时将会把所有的『环境变量』秀出来喔！例如：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">export</span>
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
declare -x LANG="zh_TW.UTF-8"
declare -x LC_ALL="en_US.utf8"
<span class="term_say"># 后面的鸟哥就都直接省略了！不然....浪费版面～ ^_^</span>
</pre></td></tr></tbody></table>
		<p>那如何将环境变量转成自订变量呢？可以使用本章后续介绍的 <a href="0320bash.html#declare">declare</a> 呢！</p>
	<br></div><br>
	<a id="variable_locale"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.4 影响显示结果的语系变量 (locale)</h2>
		<p>还记得我们在<a href="0160startlinux.html#cmd_cmd_lang">第四章里面提到的语系问题</a>吗？
		就是当我们使用 man command 的方式去查找某个数据的说明档时，该说明档的内容可能会因为我们使用的语系不同而产生乱码。
		另外，利用 ls 查找文件的时间时，也可能会有乱码出现在时间的部分。那个问题其实就是语系的问题啦。</p>
		<p>目前大多数的 Linux distributions 已经都是支持日渐流行的万国码了，也都支持大部分的国家语系。
		那么我们的 Linux 到底支持了多少的语系呢？这可以由 locale 这个指令来查找到喔！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">locale -a</span>
<span class="term_say">....(前面省略)....</span>
zh_TW
zh_TW.big5     <span class="term_note">&lt;==大五码的中文编码</span>
zh_TW.euctw
zh_TW.utf8     <span class="term_note">&lt;==万国码的中文编码</span>
zu_ZA
zu_ZA.iso88591
zu_ZA.utf8
</pre></td></tr></tbody></table>
		<p>正体中文语系至少支持了两种以上的编码，一种是目前还是很常见的 big5 ，另一种则是越来越热门的 utf-8 编码。
		那么我们如何修订这些编码呢？其实可以透过底下这些变量的说：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">locale</span>  <span class="term_note">&lt;==后面不加任何选项与参数即可！</span>
LANG=en_US                   <span class="term_note">&lt;==主语言的环境</span>
LC_CTYPE="en_US"             <span class="term_note">&lt;==字符(文本)辨识的编码</span>
LC_NUMERIC="en_US"           <span class="term_note">&lt;==数字系统的显示消息</span>
LC_TIME="en_US"              <span class="term_note">&lt;==时间系统的显示数据</span>
LC_COLLATE="en_US"           <span class="term_note">&lt;==字符串的比较与排序等</span>
LC_MONETARY="en_US"          <span class="term_note">&lt;==币值格式的显示等</span>
LC_MESSAGES="en_US"          <span class="term_note">&lt;==消息显示的内容，如功能表、错误消息等</span>
LC_ALL=                      <span class="term_note">&lt;==整体语系的环境</span>
<span class="term_say">....(后面省略)....</span>
</pre></td></tr></tbody></table>
		<p>基本上，你可以逐一设置每个与语系有关的变量数据，但事实上，如果其他的语系变量都未设置，
		且<span class="text_import2">你有设置 LANG 或者是 LC_ALL 时，则其他的语系变量就会被这两个变量所取代！</span>
		这也是为什么我们在 Linux 当中，通常说明仅设置 LANG 或 LC_ALL 这两个变量而已，因为他是最主要的设置变量！
		好了，那么你应该要觉得奇怪的是，为什么在 Linux 主机的终端机接口 (tty1 ~ tty6) 
		的环境下，如果设置『 LANG=zh_TW.utf8 』这个设置值生效后，使用 man 或者其他消息输出时，
		都会有一堆乱码，尤其是使用 ls -l 这个参数时？</p>
		<p>因为在 Linux 主机的终端机接口环境下是无法显示像中文这么复杂的编码文本，
		所以就会产生乱码了。也就是如此，我们才会必须要在 tty1 ~ tty6 的环境下，
		加装一些中文化接口的软件，才能够看到中文啊！不过，如果你是在 MS Windows 
		主机以远程连接服务器的软件连接到主机的话，那么，嘿嘿！其实文本接口确实是可以看到中文的。
		此时反而你得要在 LC_ALL 设置中文编码才好呢！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		无论如何，如果发生一些乱码的问题，那么设置系统里面保有的语系编码，
		例如： en_US 或 en_US.utf8 等等的设置，应该就 OK 的啦！好了，那么系统缺省支持多少种语系呢？
		当我们使用 locale 时，系统是列出目前 Linux 主机内保有的语系文件，
		这些语系文件都放置在： <span class="text_import2">/usr/lib/locale/</span> 这个目录中。
		</fieldset><br>
		<p>你当然可以让每个用户自己去调整自己喜好的语系，但是整体系统缺省的语系定义在哪里呢？
		其实就是在 /etc/locale.conf 啰！这个文件在 CentOS 7.x 的内容有点像这样：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cat /etc/locale.conf</span>
LANG=zh_TW.utf8
LC_NUMERIC=zh_TW.UTF-8
LC_TIME=zh_TW.UTF-8
LC_MONETARY=zh_TW.UTF-8
LC_PAPER=zh_TW.UTF-8
LC_MEASUREMENT=zh_TW.UTF-8
</pre></td></tr></tbody></table>
		<p>因为鸟哥在<a href="0157installcentos7.html">第三章的安装时</a>选择的是中文语系安装画面，
		所以这个文件缺省就会使用中文编码啦！你也可以自行将他改成你想要的语系编码即可。</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		假设你有一个纯文本文件原本是在 Windows 底下创建的，那么这个文件缺省可能是 big5 的编码格式。
		在你将这个文件上传到 Linux 主机后，在 X window 底下打开时，咦！怎么中文本通通变成乱码了？
		别担心！因为如上所示， Linux 目前大多缺省是万国码显示嘛！你只要将开启该文件的软件编码由 utf8 
		改成 big5 就能够看到正确的中文了！
		</fieldset><br>
<table class="exam"><tbody><tr><td>
例题：<div>
鸟哥原本是中文语系，所有显示的数据通通是中文。但为了网页显示的关系，需要将输出转成英文 (en_US.utf8) 的语系来展示才行。
但鸟哥又不想要写入设置档！毕竟是暂时显示用的～那该如何处理？</div>
答：<div>
其实不很难，重点是 LANG 及 LC_ALL 而已！但在 CentOS 7 当中，你要让 LC_ALL 生效时，得要使用 export 转成环境变量才行耶！
所以就是这样搞：
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">locale</span>
LANG=zh_TW.UTF-8
LC_CTYPE="zh_TW.UTF-8"
LC_NUMERIC="zh_TW.UTF-8"
LC_TIME="zh_TW.UTF-8"
[dmtsai@study ~]$ <span class="term_command">LANG=en_US.utf8; locale</span>
[dmtsai@study ~]$ <span class="term_command">export LC_ALL=en_US.utf8; locale</span>  <span class="term_note"># 你就会看到与上头有不同的语系啰！</span>
</pre></td></tr></tbody></table>
</div>
</td></tr></tbody></table><br>
	<br></div><br>
	<a id="variable_range"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.5 变量的有效范围</h2>
		<p>虾密？变量也有使用的『范围』？没错啊～我们在上头的 <a href="0320bash.html#export">export</a> 
		指令说明中，就提到了这个概念了。如果在跑程序的时候，有父进程与子进程的不同进程关系时，
		则『变量』可否被引用与 export 有关。被 export 后的变量，我们可以称他为『环境变量』！
		环境变量可以被子进程所引用，但是其他的自订变量内容就不会存在于子进程中。</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		在某些不同的书籍会谈到『全域变量, global variable』与『区域变量, local variable』。
		在鸟哥的这个章节中，基本上你可以这样看待：<br>环境变量=全域变量<br>自订变量=区域变量
		</fieldset><br>
		<p>在学理方面，为什么环境变量的数据可以被子进程所引用呢？这是因为内存配置的关系！理论上是这样的：</p>
		<ul style="padding-left: 25px">
		<li>当启动一个 shell，操作系统会分配一记忆区块给 shell 使用，此内存内之变量可让子进程取用</li>
		<li>若在父进程利用 export 功能，可以让自订变量的内容写到上述的记忆区块当中(环境变量)；</li>
		<li>当加载另一个 shell 时 (亦即启动子进程，而离开原本的父进程了)，子 shell 可以将父 shell 
			的环境变量所在的记忆区块导入自己的环境变量区块当中。</li>
		</ul>
		<p>透过这样的关系，我们就可以让某些变量在相关的进程之间存在，以帮助自己更方便的操作环境喔！
		不过要提醒的是，这个『环境变量』与『bash 的操作环境』意思不太一样，举例来说， PS1 并不是环境变量，
		但是这个 PS1 会影响到 bash 的接口 (提示字符嘛)！相关性要厘清喔！^_^</p>
	<br></div><br>
	<a id="variable_read"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.6 变量键盘读取、数组与声明： read, array, declare</h2>
		<p>我们上面提到的变量设置功能，都是由指令列直接设置的，那么，可不可以让用户能够经由键盘输入？
		什么意思呢？是否记得某些程序运行的过程当中，会等待用户输入 "yes/no" 之类的消息啊？
		在 bash 里面也有相对应的功能喔！此外，我们还可以声明这个变量的属性，例如：数组或者是数字等等的。底下就来看看吧！</p>
		<a id="read"></a>
		<ul class="toplist"><li>read</li></ul>
		<p>要读取来自键盘输入的变量，就是用 read 这个指令了。这个指令最常被用在 shell script 的撰写当中，
		想要跟用户对谈？用这个指令就对了。关于 script 的写法，我们会在第十三章介绍，底下先来瞧一瞧 read 的相关语法吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">read [-pt] variable</span>
<span class="term_say">选项与参数：
-p  ：后面可以接提示字符！
-t  ：后面可以接等待的『秒数！』这个比较有趣～不会一直等待用户啦！</span>
<span class="term_hd">范例一：让用户由键盘输入一内容，将该内容变成名为 atest 的变量</span>
[dmtsai@study ~]$ <span class="term_command">read atest</span>
<span class="term_command">This is a test</span>        <span class="term_note">&lt;==此时光标会等待你输入！请输入左侧文本看看</span>
[dmtsai@study ~]$ <span class="term_command">echo ${atest}</span>
This is a test          <span class="term_note">&lt;==你刚刚输入的数据已经变成一个变量内容！</span>
<span class="term_hd">范例二：提示用户 30 秒内输入自己的大名，将该输入字符串作为名为 named 的变量内容</span>
[dmtsai@study ~]$ <span class="term_command">read -p "Please keyin your name: " -t 30 named</span>
Please keyin your name: <span class="term_command">VBird Tsai</span>   <span class="term_note">&lt;==注意看，会有提示字符喔！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${named}</span>
VBird Tsai        <span class="term_note">&lt;==输入的数据又变成一个变量的内容了！</span>
</pre></td></tr></tbody></table>
		<p>read 之后不加任何参数，直接加上变量名称，那么底下就会主动出现一个空白行等待你的输入(如范例一)。
		如果加上 -t 后面接秒数，例如上面的范例二，那么 30 秒之内没有任何动作时，
		该指令就会自动略过了～如果是加上 -p ，嘿嘿！在输入的光标前就会有比较多可以用的提示字符给我们参考！
		在指令的下达里面，比较美观啦！ ^_^</p>
		<a id="declare"></a>
		<ul class="toplist"><li>declare / typeset</li></ul>
		<p>declare 或 typeset 是一样的功能，就是在『<span class="text_import2">声明变量的类型</span>』。如果使用 
		declare 后面并没有接任何参数，那么 bash 就会主动的将所有的变量名称与内容通通叫出来，就好像使用 set 一样啦！
		那么 declare 还有什么语法呢？看看先：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">declare [-aixr] variable</span>
<span class="term_say">选项与参数：
-a  ：将后面名为 variable 的变量定义成为数组 (array) 类型
-i  ：将后面名为 variable 的变量定义成为整数数字 (integer) 类型
-x  ：用法与 export 一样，就是将后面的 variable 变成环境变量；
-r  ：将变量设置成为 readonly 类型，该变量不可被更改内容，也不能 unset</span>
<span class="term_hd">范例一：让变量 sum 进行 100+300+50 的加总结果</span>
[dmtsai@study ~]$ <span class="term_command">sum=100+300+50</span>
[dmtsai@study ~]$ <span class="term_command">echo ${sum}</span>
100+300+50  <span class="term_note">&lt;==咦！怎么没有帮我计算加总？因为这是文本型态的变量属性啊！</span>
[dmtsai@study ~]$ <span class="term_command">declare -i sum=100+300+50</span>
[dmtsai@study ~]$ <span class="term_command">echo ${sum}</span>
450         <span class="term_note">&lt;==瞭乎？？</span>
</pre></td></tr></tbody></table>
		<p>由于在缺省的情况底下， bash 对于变量有几个基本的定义：</p>
		<ul class="text_import2">
		<li>变量类型缺省为『字符串』，所以若不指定变量类型，则 1+2 为一个『字符串』而不是『计算式』。
			所以上述第一个运行的结果才会出现那个情况的；</li>
		<li>bash 环境中的数值运算，缺省最多仅能到达整数形态，所以 1/3 结果是 0；</li>
		</ul>
		<p>现在你晓得为啥你需要进行变量声明了吧？如果需要非字符串类型的变量，那就得要进行变量的声明才行啦！
		底下继续来玩些其他的 declare 功能。</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：将 sum 变成环境变量</span>
[dmtsai@study ~]$ <span class="term_command">declare -x sum</span>
[dmtsai@study ~]$ <span class="term_command">export | grep sum</span>
declare -ix sum="450"  <span class="term_note">&lt;==果然出现了！包括有 i 与 x 的声明！</span>
<span class="term_hd">范例三：让 sum 变成唯读属性，不可更动！</span>
[dmtsai@study ~]$ <span class="term_command">declare -r sum</span>
[dmtsai@study ~]$ <span class="term_command">sum=tesgting</span>
-bash: sum: readonly variable  <span class="term_note">&lt;==老天爷～不能改这个变量了！</span>
<span class="term_hd">范例四：让 sum 变成非环境变量的自订变量吧！</span>
[dmtsai@study ~]$ <span class="term_command">declare +x sum</span>  <span class="term_note">&lt;== 将 - 变成 + 可以进行『取消』动作</span>
[dmtsai@study ~]$ <span class="term_command">declare -p sum</span>  <span class="term_note">&lt;== -p 可以单独列出变量的类型</span>
declare -ir sum="450" <span class="term_note">&lt;== 看吧！只剩下 i, r 的类型，不具有 x 啰！</span>
</pre></td></tr></tbody></table>
		<p>declare 也是个很有用的功能～尤其是当我们需要使用到底下的数组功能时，
		他也可以帮我们声明数组的属性喔！不过，老话一句，数组也是在 shell script 比较常用的啦！
		比较有趣的是，如果你不小心将变量设置为『唯读』，通常得要注销再登录才能复原该变量的类型了！ @_@</p>
		<a id="array"></a>
		<ul class="toplist"><li>数组 (array) 变量类型</li></ul>
		<p>某些时候，我们必须使用数组来声明一些变量，这有什么好处啊？在一般人的使用上，
		果然是看不出来有什么好处的！不过，如果您曾经写过程序的话，那才会比较了解数组的意义～
		数组对写数值程序的设计师来说，可是不能错过学习的重点之一哩！好！不啰唆～
		那么要如何设置数组的变量与内容呢？在 bash 里头，数组的设置方式是：</p>
		<blockquote class="text_import2">var[index]=content</blockquote>
		<p>意思是说，我有一个数组名称为 var ，而这个数组的内容为 var[1]=小明， var[2]=大明， 
		var[3]=好明 .... 等等，那个 index 就是一些数字啦，重点是用中刮号 ([ ]) 来设置的。
		目前我们 bash 提供的是一维数组。老实说，如果您不必写一些复杂的程序，
		那么这个数组的地方，可以先略过，等到有需要再来学习即可！因为要制作出数组，
		通常与循环或者其他判断式交互使用才有比较高的存在意义！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例：设置上面提到的 var[1] ～ var[3] 的变量。</span>
[dmtsai@study ~]$ <span class="term_command">var[1]="small min"</span>
[dmtsai@study ~]$ <span class="term_command">var[2]="big min"</span>
[dmtsai@study ~]$ <span class="term_command">var[3]="nice min"</span>
[dmtsai@study ~]$ <span class="term_command">echo "${var[1]}, ${var[2]}, ${var[3]}"</span>
small min, big min, nice min
</pre></td></tr></tbody></table>
		<p>数组的变量类型比较有趣的地方在于『读取』，一般来说，<span class="text_import2">建议直接以 ${数组}
		的方式来读取</span>，比较正确无误的啦！这也是为啥鸟哥一开始就建议你使用 ${变量} 来记忆的原因！</p>
	<br></div><br>
	<a id="variable_ulimit"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.7 与文件系统及进程的限制关系： ulimit</h2>
		<p>想像一个状况：我的 Linux 主机里面同时登录了十个人，这十个人不知怎么搞的，
		同时开启了 100 个文件，每个文件的大小约 10MBytes ，请问一下，
		我的 Linux 主机的内存要有多大才够？ 10*100*10 = 10000 MBytes = 10GBytes ...
		老天爷，这样，系统不挂点才有鬼哩！为了要预防这个情况的发生，所以<span class="text_import2">我们的 bash 
		是可以『限制用户的某些系统资源』的，包括可以开启的文件数量，
		可以使用的 CPU 时间，可以使用的内存总量等等</span>。如何设置？用 ulimit 吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">ulimit [-SHacdfltu] [配额]</span>
<span class="term_say">选项与参数：
-H  ：hard limit ，严格的设置，必定不能超过这个设置的数值；
-S  ：soft limit ，警告的设置，可以超过这个设置值，但是若超过则有警告消息。
      在设置上，通常 soft 会比 hard 小，举例来说，soft 可设置为 80 而 hard 
      设置为 100，那么你可以使用到 90 (因为没有超过 100)，但介于 80~100 之间时，
      系统会有警告消息通知你！
-a  ：后面不接任何选项与参数，可列出所有的限制额度；
-c  ：当某些程序发生错误时，系统可能会将该程序在内存中的信息写成文件(调试用)，
      这种文件就被称为核心文件(core file)。此为限制每个核心文件的最大容量。
-f  ：此 shell 可以创建的最大文件容量(一般可能设置为 2GB)单位为 Kbytes
-d  ：进程可使用的最大断裂内存(segment)容量；
-l  ：可用于锁定 (lock) 的内存量
-t  ：可使用的最大 CPU 时间 (单位为秒)
-u  ：单一用户可以使用的最大进程(process)数量。</span>
<span class="term_hd">范例一：列出你目前身份(假设为一般帐号)的所有限制数据数值</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -a</span>
core file size          (blocks, -c) 0          <span class="term_note">&lt;==只要是 0 就代表没限制</span>
data seg size           (kbytes, -d) unlimited
scheduling priority             (-e) 0
<span class="term_write">file size               (blocks, -f) unlimited  <span class="term_note">&lt;==可创建的单一文件的大小</span></span>
pending signals                 (-i) 4903
max locked memory       (kbytes, -l) 64
max memory size         (kbytes, -m) unlimited
<span class="term_write">open files                      (-n) 1024       <span class="term_note">&lt;==同时可开启的文件数量</span></span>
pipe size            (512 bytes, -p) 8
POSIX message queues     (bytes, -q) 819200
real-time priority              (-r) 0
stack size              (kbytes, -s) 8192
cpu time               (seconds, -t) unlimited
max user processes              (-u) 4096
virtual memory          (kbytes, -v) unlimited
file locks                      (-x) unlimited
<span class="term_hd">范例二：限制用户仅能创建 10MBytes 以下的容量的文件</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -f 10240</span>
[dmtsai@study ~]$ <span class="term_command">ulimit -a | grep 'file size'</span>
core file size          (blocks, -c) 0
file size               (blocks, -f) 10240 <span class="term_note">&lt;==最大量为10240Kbyes，相当10Mbytes</span>
[dmtsai@study ~]$ <span class="term_command">dd if=/dev/zero of=123 bs=1M count=20</span>
File size limit exceeded (core dumped) <span class="term_note">&lt;==尝试创建 20MB 的文件，结果失败了！</span>
[dmtsai@study ~]$ <span class="term_command">rm 123</span>  <span class="term_note">&lt;==赶快将这个文件删除啰！同时你得要注销再次的登录才能解开 10M 的限制</span>
</pre></td></tr></tbody></table>
		<p>还记得我们在<a href="0230filesystem.html">第七章 Linux 磁盘文件系统</a>里面提到过，单一 filesystem
		能够支持的单一文件大小与 block 的大小有关。但是文件系统的限制容量都允许的太大了！如果想要让用户创建的文件不要太大时，
		我们是可以考虑用 ulimit 来限制用户可以创建的文件大小喔！利用 ulimit -f 就可以来设置了！例如上面的范例二，要注意单位喔！单位是 Kbytes。
		若改天你一直无法创建一个大容量的文件，记得瞧一瞧 ulimit 的信息喔！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		想要复原 ulimit 的设置最简单的方法就是注销再登录，否则就是得要重新以 ulimit 设置才行！
		不过，要注意的是，一般身份用户如果以 ulimit 设置了 -f 的文件大小，
		那么他『只能继续减小文件容量，不能增加文件容量喔！』另外，若想要管控用户的 ulimit 限值，
		可以参考<a href="0410accountmanager.html#limits">第十三章的 pam</a> 的介绍。
		</fieldset><br>	</div><br>
	<a id="variable_other"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.2.8 变量内容的删除、取代与替换 (Optional)</h2>
		<p>变量除了可以直接设置来修改原本的内容之外，有没有办法透过简单的动作来将变量的内容进行微调呢？
		举例来说，进行变量内容的删除、取代与替换等！是可以的！我们可以透过几个简单的小步骤来进行变量内容的微调喔！
		底下就来试试看！</p>
		<a id="variable_other_replace"></a>
		<ul class="toplist"><li>变量内容的删除与取代</li></ul>
		<p>变量的内容可以很简单的透过几个咚咚来进行删除喔！我们使用 PATH 这个变量的内容来做测试好了。
		请你依序进行底下的几个例子来玩玩，比较容易感受的到鸟哥在这里想要表达的意义：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：先让小写的 path 自订变量设置的与 PATH 内容相同</span>
[dmtsai@study ~]$ <span class="term_command">path=${PATH}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path}</span>
<span class="term_write">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_hd">范例二：假设我不喜欢 local/bin，所以要将前 1 个目录删除掉，如何显示？</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path#/*local/bin:}</span>
/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</pre></td></tr></tbody></table>
		<p>上面这个范例很有趣的！他的重点可以用底下这张表格来说明：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_command">${</span>variable#/*local/bin:<span class="term_command">}</span>
<span class="term_say">   上面的特殊字体部分是关键字！用在这种删除模式所必须存在的</span>
${<span class="term_command">variable</span>#/*local/bin:}
<span class="term_say">   这就是原本的变量名称，以上面范例二来说，这里就填写 path 这个『变量名称』啦！</span>
${variable<span class="term_command">#</span>/*local/bin:}
<span class="term_say">   这是重点！代表『从变量内容的最前面开始向右删除』，且仅删除最短的那个</span>
${variable#<span class="term_command">/*local/bin:</span>}
<span class="term_say">   代表要被删除的部分，由于 # 代表由前面开始删除，所以这里便由开始的 / 写起。
   需要注意的是，我们还可以透过通配符 * 来取代 0 到无穷多个任意字符</span>
<span class="term_say">   以上面范例二的结果来看， path 这个变量被删除的内容如下所示：</span>
<span style="text-decoration: line-through">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
</pre></td></tr></tbody></table>
		<p>很有趣吧！这样了解了 # 的功能了吗？接下来让我们来看看底下的范例三！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我想要删除前面所有的目录，仅保留最后一个目录</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path#/*:}</span>
/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 由于一个 # 仅删除掉最短的那个，因此他删除的情况可以用底下的删除线来看：
# <span style="text-decoration: line-through">/usr/local/bin:</span>/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path##/*:}</span>
/home/dmtsai/bin
<span class="term_say"># 嘿！多加了一个 # 变成 ## 之后，他变成『删除掉最长的那个数据』！亦即是：
# <span style="text-decoration: line-through">/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:</span>/home/dmtsai/bin</span>
</pre></td></tr></tbody></table>
		<p>非常有趣！不是吗？因为在 PATH 这个变量的内容中，每个目录都是以冒号『:』隔开的，
		所以要从头删除掉目录就是介于斜线 (/) 到冒号 (:) 之间的数据！但是 PATH 中不止一个冒号 (:) 啊！
		所以 # 与 ## 就分别代表：</p>
		<ul class="text_import2" style="font-family: &#39;细明体&#39;">
		<li># ：符合取代文本的『最短的』那一个；</li>
		<li>##：符合取代文本的『最长的』那一个</li></ul>
		<p>上面谈到的是『从前面开始删除变量内容』，那么如果想要『从后面向前删除变量内容』呢？
		这个时候就得使用百分比 (%) 符号了！来看看范例四怎么做吧！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：我想要删除最后面那个目录，亦即从 : 到 bin 为止的字符串</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path%:*bin}</span>
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin
<span class="term_say"># 注意啊！最后面一个目录不见去！</span>
<span class="term_say"># 这个 % 符号代表由最后面开始向前删除！所以上面得到的结果其实是来自如下：
# /usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin<span style="text-decoration: line-through">:/home/dmtsai/bin</span></span>
<span class="term_hd">范例五：那如果我只想要保留第一个目录呢？</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path%%:*bin}</span>
/usr/local/bin
<span class="term_say"># 同样的， %% 代表的则是最长的符合字符串，所以结果其实是来自如下：
# /usr/local/bin<span style="text-decoration: line-through">:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin</span></span>
</pre></td></tr></tbody></table>
		<p>由于我是想要由变量内容的后面向前面删除，而我这个变量内容最后面的结尾是『/home/dmtsai/bin』，
		所以你可以看到上面我删除的数据最终一定是『bin』，亦即是『:*bin』那个 * 代表通配符！
		至于 % 与 %% 的意义其实与 # 及 ## 类似！这样理解否？</p>
<table class="exam" style="width:90%"><tbody><tr><td>
例题：<div>
假设你是 dmtsai ，那你的 MAIL 变量应该是 /var/spool/mail/dmtsai 。假设你只想要保留最后面那个文件名 (dmtsai)，
前面的目录名称都不要了，如何利用 $MAIL 变量来达成？
</div>
答：<div>
题意其实是这样『<span style="text-decoration: line-through">/var/spool/mail/</span>dmtsai』，亦即删除掉两条斜线间的所有数据(最长符合)。
这个时候你就可以这样做即可：
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo ${MAIL##/*/}</span>
</pre></td></tr></tbody></table>
相反的，如果你只想要拿掉文件名，保留目录的名称，亦即是『/var/spool/mail<span style="text-decoration: line-through">/dmtsai</span>』
(最短符合)。但假设你并不知道结尾的字母为何，此时你可以利用通配符来处理即可，如下所示：
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo ${MAIL%/*}</span>
</pre></td></tr></tbody></table>
</div>
</td></tr></tbody></table>
		<p>了解了删除功能后，接下来谈谈取代吧！继续玩玩范例六啰！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：将 path 的变量内容内的 sbin 取代成大写 SBIN：</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path/sbin/SBIN}</span>
/usr/local/bin:/usr/bin:/usr/local/<span class="term_write">SBIN</span>:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 这个部分就容易理解的多了！关键字在于那两个斜线，两斜线中间的是旧字符串
# 后面的是新字符串，所以结果就会出现如上述的特殊字体部分啰！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${path//sbin/SBIN}</span>
/usr/local/bin:/usr/bin:/usr/local/<span class="term_write">SBIN</span>:/usr/<span class="term_write">SBIN</span>:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say"># 如果是两条斜线，那么就变成所有符合的内容都会被取代喔！</span>
</pre></td></tr></tbody></table>
		<p>我们将这部份作个总结说明一下：</p>
<table class="news">
<tbody><tr class="theader"><td style="width:180px">变量设置方式</td><td>说明</td></tr>
<tr><td style="font-family:&#39;细明体&#39;"><u>${</u>变量<u>#</u>关键字<u>}</u><br><u>${</u>变量<u>##</u>关键字<u>}</u></td>
	<td>若变量内容从头开始的数据符合『关键字』，则将符合的最短数据删除<br>
	若变量内容从头开始的数据符合『关键字』，则将符合的最长数据删除</td></tr>
<tr><td style="font-family:&#39;细明体&#39;"><u>${</u>变量<u>%</u>关键字<u>}</u><br><u>${</u>变量<u>%%</u>关键字<u>}</u></td>
	<td>若变量内容从尾向前的数据符合『关键字』，则将符合的最短数据删除<br>
	若变量内容从尾向前的数据符合『关键字』，则将符合的最长数据删除</td></tr>
<tr><td style="font-family:&#39;细明体&#39;"><u>${</u>变量<u>/</u>旧字符串<u>/</u>新字符串<u>}</u><br><u>${</u>变量<u>//</u>旧字符串<u>/</u>新字符串<u>}</u></td>
	<td>若变量内容符合『旧字符串』则『第一个旧字符串会被新字符串取代』<br>
	若变量内容符合『旧字符串』则『全部的旧字符串会被新字符串取代』</td></tr>
</tbody></table>
		<a id="variable_other_re"></a>
		<ul class="toplist"><li>变量的测试与内容替换</li></ul>
		<p>在某些时刻我们常常需要『判断』某个变量是否存在，若变量存在则使用既有的设置，若变量不存在则给予一个常用的设置。
		我们举底下的例子来说明好了，看看能不能较容易被你所理解呢！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：测试一下是否存在 username 这个变量，若不存在则给予 username 内容为 root</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
           <span class="term_note">&lt;==由于出现空白，所以 username 可能不存在，也可能是空字符串</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
root       <span class="term_note">&lt;==因为 username 没有设置，所以主动给予名为 root 的内容。</span>
[dmtsai@study ~]$ <span class="term_command">username="vbird tsai"</span> <span class="term_note">&lt;==主动设置 username 的内容</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
vbird tsai <span class="term_note">&lt;==因为 username 已经设置了，所以使用旧有的设置而不以 root 取代</span>
</pre></td></tr></tbody></table>
		<p>在上面的范例中，重点在于减号『 - 』后面接的关键字！基本上你可以这样理解：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_command">new_var</span>=${old_var-content}
   <span class="term_say">新的变量，主要用来取代旧变量。新旧变量名称其实常常是一样的</span>
new_var=<span class="term_command">${</span>old_var<span class="term_command">-</span>content<span class="term_command">}</span>
   <span class="term_say">这是本范例中的关键字部分！必须要存在的哩！</span>
new_var=${<span class="term_command">old_var</span>-content}
   <span class="term_say">旧的变量，被测试的项目！</span>
new_var=${old_var-<span class="term_command">content</span>}
   <span class="term_say">变量的『内容』，在本范例中，这个部分是在『给予未设置变量的内容』</span>
</pre></td></tr></tbody></table>
		<p>不过这还是有点问题！因为 username 可能已经被设置为『空字符串』了！果真如此的话，那你还可以使用底下的范例来给予
		username 的内容成为 root 喔！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：若 username 未设置或为空字符串，则将 username 内容设置为 root</span>
[dmtsai@study ~]$ <span class="term_command">username=""</span>
[dmtsai@study ~]$ <span class="term_command">username=${username-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
      <span class="term_note">&lt;==因为 username 被设置为空字符串了！所以当然还是保留为空字符串！</span>
[dmtsai@study ~]$ <span class="term_command">username=${username:-root}</span>
[dmtsai@study ~]$ <span class="term_command">echo ${username}</span>
root  <span class="term_note">&lt;==加上『 : 』后若变量内容为空或者是未设置，都能够以后面的内容替换！</span>
</pre></td></tr></tbody></table>
		<p>在大括号内有没有冒号『 : 』的差别是很大的！加上冒号后，被测试的变量未被设置或者是已被设置为空字符串时，
		都能够用后面的内容 (本例中是使用 root 为内容) 来替换与设置！这样可以了解了吗？除了这样的测试之外，
		还有其他的测试方法喔！鸟哥将他整理如下：</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		底下的例子当中，那个 var 与 str 为变量，我们想要针对 str 是否有设置来决定 var 的值喔！
		一般来说， str: 代表『str 没设置或为空的字符串时』；至于 str 则仅为『没有该变量』。
		</fieldset><br>
<a id="20070715"></a>
<table class="news">
<tbody><tr class="theader"><td>变量设置方式</td><td>str 没有设置</td>
	<td>str 为空字符串</td><td>str 已设置非为空字符串</td></tr>
<tr>	<td>var=${str-expr}</td><td>var=expr</td><td>var=</td><td>var=$str</td></tr>
<tr>	<td>var=${str:-expr}</td><td>var=expr</td><td>var=expr</td><td>var=$str</td></tr>
<tr>	<td>var=${str+expr}</td><td>var=</td><td>var=expr</td><td>var=expr</td></tr>
<tr>    <td>var=${str:+expr}</td><td>var=</td><td>var=</td><td>var=expr</td></tr>
<tr>	<td>var=${str=expr}</td><td>str=expr<br>var=expr</td>
	<td>str 不变<br>var=</td><td>str 不变<br>var=$str</td></tr>
<tr>	<td>var=${str:=expr}</td><td>str=expr<br>var=expr</td>
	<td>str=expr<br>var=expr</td><td>str 不变<br>var=$str</td></tr>
<tr>	<td>var=${str?expr}</td><td>expr 输出至 stderr</td><td>var=</td><td>var=$str</td></tr>
<tr>	<td>var=${str:?expr}</td><td>expr 输出至 stderr</td><td>expr 输出至 stderr</td><td>var=$str</td></tr>
</tbody></table>
		<p>根据上面这张表，我们来进行几个范例的练习吧！ ^_^！首先让我们来测试一下，如果旧变量 (str) 不存在时，
		我们要给予新变量一个内容，若旧变量存在则新变量内容以旧变量来替换，结果如下：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：先假设 str 不存在 (用 unset) ，然后测试一下减号 (-) 的用法：</span>
[dmtsai@study ~]$ <span class="term_command">unset str; var=${str-newvar}</span>
[dmtsai@study ~]$ <span class="term_command">echo "var=${var}, str=${str}"</span>
var=newvar, str=        <span class="term_note">&lt;==因为 str 不存在，所以 var 为 newvar</span>
<span class="term_hd">测试：若 str 已存在，测试一下 var 会变怎样？：</span>
[dmtsai@study ~]$ <span class="term_command">str="oldvar"; var=${str-newvar}</span>
[dmtsai@study ~]$ <span class="term_command">echo "var=${var}, str=${str}"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>
		<p>关于减号 (-) 其实上面我们谈过了！这里的测试只是要让你更加了解，这个减号的测试并不会影响到旧变量的内容。
		如果你想要将旧变量内容也一起替换掉的话，那么就使用等号 (=) 吧！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：先假设 str 不存在 (用 unset) ，然后测试一下等号 (=) 的用法：</span>
[dmtsai@study ~]$ <span class="term_command">unset str; var=${str=newvar}</span>
[dmtsai@study ~]$ <span class="term_command">echo "var=${var}, str=${str}"</span>
var=newvar, str=newvar  <span class="term_note">&lt;==因为 str 不存在，所以 var/str 均为 newvar</span>
<span class="term_hd">测试：如果 str 已存在了，测试一下 var 会变怎样？</span>
[dmtsai@study ~]$ <span class="term_command">str="oldvar"; var=${str=newvar}</span>
[dmtsai@study ~]$ <span class="term_command">echo "var=${var}, str=${str}"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>
		<p>那如果我只是想知道，如果旧变量不存在时，整个测试就告知我『有错误』，此时就能够使用问号『 ? 』的帮忙啦！
		底下这个测试练习一下先！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">测试：若 str 不存在时，则 var 的测试结果直接显示 "无此变量"</span>
[dmtsai@study ~]$ <span class="term_command">unset str; var=${str?无此变量}</span>
-bash: str: 无此变量    <span class="term_note">&lt;==因为 str 不存在，所以输出错误消息 </span>
<span class="term_hd">测试：若 str 存在时，则 var 的内容会与 str 相同！</span>
[dmtsai@study ~]$ <span class="term_command">str="oldvar"; var=${str?novar}</span>
[dmtsai@study ~]$ <span class="term_command">echo "var=${var}, str=${str}"</span>
var=oldvar, str=oldvar  <span class="term_note">&lt;==因为 str 存在，所以 var 等于 str 的内容</span>
</pre></td></tr></tbody></table>
		<p>基本上这种变量的测试也能够透过 shell script 内的 if...then... 来处理，
		不过既然 bash 有提供这么简单的方法来测试变量，那我们也可以多学一些嘛！
		不过这种变量测试通常是在编程当中比较容易出现，如果这里看不懂就先略过，未来有用到判断变量值时，再回来看看吧！ ^_^</p>
	<br></div>
</div>
<a id="alias_history"></a>
<div class="block1">
<h2>10.3 命令别名与历史命令</h2>
	<p>我们知道在早期的 DOS 年代，清除屏幕上的信息可以使用 cls 来清除，但是在 Linux 里面，
	我们则是使用 clear 来清除画面的。那么可否让 cls 等于 clear 呢？可以啊！用啥方法？
	link file 还是什么的？别急！底下我们介绍不用 link file 的命令别名来达成。那么什么又是历史命令？
	曾经做过的举动我们可以将他记录下来喔！那就是历史命令啰～底下分别来谈一谈这两个玩意儿。</p>
	<a id="alias"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.3.1 命令别名设置： alias, unalias</h2>
		<p>命令别名是一个很有趣的东西，特别是你的惯用指令特别长的时候！还有，
		增设缺省的选项在一些惯用的指令上面，可以预防一些不小心误杀文件的情况发生的时候！
		举个例子来说，如果你要查找隐藏档，并且需要长的列出与一页一页翻看，那么需要下达『
		<span class="text_import2">ls -al | more </span>』这个指令，鸟哥是觉得很烦啦！
		要输入好几个单字！那可不可以使用 lm 来简化呢？当然可以，你可以在命令行下面下达：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">alias lm='ls -al | more'</span>
</pre></td></tr></tbody></table>
		<p>立刻多出了一个可以运行的指令喔！这个指令名称为 lm ，且其实他是运行 ls -al | more 啊！真是方便。不过，
		要注意的是：『alias 的定义规则与<a href="0320bash.html#variable_rule">变量定义规则</a>几乎相同』，
		所以你只要在 alias 后面加上你的 {<span class="text_import2">『别名』='指令 选项...'</span> }，
		以后你只要输入 lm 就相当于输入了 ls -al|more 这一串指令！很方便吧！</p>
		<p>另外，命令别名的设置还可以取代既有的指令喔！举例来说，我们知道 root
		可以移除 (rm) 任何数据！所以当你以 root 的身份在进行工作时，需要特别小心，
		但是总有失手的时候，那么 rm 提供了一个选项来让我们确认是否要移除该文件，那就是 -i 
		这个选项！所以，你可以这样做：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">alias rm='rm -i'</span>
</pre></td></tr></tbody></table>
		<p>那么以后使用 rm 的时候，就不用太担心会有错误删除的情况了！这也是命令别名的优点啰！
		那么如何知道目前有哪些的命令别名呢？就使用 alias 呀！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">alias</span>
alias egrep='egrep --color=auto'
alias fgrep='fgrep --color=auto'
alias grep='grep --color=auto'
alias l.='ls -d .* --color=auto'
alias ll='ls -l --color=auto'
alias lm='ls -al | more'
alias ls='ls --color=auto'
alias rm='rm -i'
alias vi='vim'
alias which='alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde'
</pre></td></tr></tbody></table>
		<p>由上面的数据当中，你也会发现一件事情啊，我们在<a href="0310vi.html">第九章的 vim 程序编辑器</a>里面提到 
		vi 与 vim 是不太一样的，vim 可以多作一些额外的语法检验与颜色显示。一般用户会有 vi=vim 的命令别名，但是 root 则是单纯使用 vi 而已。
		如果你想要使用 vi 就直接以 vim 来开启文件的话，使用『 alias vi='vim' 』这个设置即可。
		至于如果要取消命令别名的话，那么就使用 unalias 吧！例如要将刚刚的 lm 命令别名拿掉，就使用：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">unalias lm</span>
</pre></td></tr></tbody></table>
		<p><span class="text_import2">那么命令别名与变量有什么不同呢</span>？命令别名是『新创一个新的指令，
		你可以直接下达该指令』的，至于变量则需要使用类似『 echo 』指令才能够调用出变量的内容！
		这两者当然不一样！很多初学者在这里老是搞不清楚！要注意啊！ ^_^</p>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
DOS 年代，列出目录与文件就是 dir ，而清除屏幕就是 cls ，那么如果我想要在
linux 里面也使用相同的指令呢？
</div>
答：<div>
很简单，透过 clear 与 ls 来进行命令别名的建置：
<blockquote style="font-family: &#39;细明体&#39;" class="text_import2">
alias cls='clear'<br>alias dir='ls -l'</blockquote>
</div>
</td></tr></tbody></table><br>
	<br></div><br>
	<a id="history"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.3.2 历史命令：history</h2>
		<p>前面我们提过 bash 有提供指令历史的服务！那么如何查找我们曾经下达过的指令呢？就使用
		history 啰！当然，如果觉得 histsory 要输入的字符太多太麻烦，可以使用命令别名来设置呢！
		不要跟我说还不会设置呦！ ^_^</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">alias h='history'</span>
</pre></td></tr></tbody></table>
		<p>如此则输入 h 等于输入 history 啰！好了，我们来谈一谈 history 的用法吧！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">history [n]</span>
[dmtsai@study ~]$ <span class="term_command">history [-c]</span>
[dmtsai@study ~]$ <span class="term_command">history [-raw] histfiles</span>
<span class="term_say">选项与参数：
n   ：数字，意思是『要列出最近的 n 笔命令行表』的意思！
-c  ：将目前的 shell 中的所有 history 内容全部消除
-a  ：将目前添加的 history 指令添加入 histfiles 中，若没有加 histfiles ，
      则缺省写入 ~/.bash_history
-r  ：将 histfiles 的内容读到目前这个 shell 的 history 记忆中；
-w  ：将目前的 history 记忆内容写入 histfiles 中！</span>
<span class="term_hd">范例一：列出目前内存内的所有 history 记忆</span>
[dmtsai@study ~]$ <span class="term_command">history</span>
<span class="term_say"># 前面省略</span>
 1017  man bash
 1018  ll
 1019  history 
 1020  history
<span class="term_say"># 列出的信息当中，共分两栏，第一栏为该指令在这个 shell 当中的代码，
# 另一个则是指令本身的内容喔！至于会秀出几笔指令记录，则与 HISTSIZE 有关！</span>
<span class="term_hd">范例二：列出目前最近的 3 笔数据</span>
[dmtsai@study ~]$ <span class="term_command">history 3</span>
 1019  history 
 1020  history
 1021  history 3
<span class="term_hd">范例三：立刻将目前的数据写入 histfile 当中</span>
[dmtsai@study ~]$ <span class="term_command">history -w</span>
<span class="term_say"># 在缺省的情况下，会将历史纪录写入 ~/.bash_history 当中！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${HISTSIZE}</span>
1000
</pre></td></tr></tbody></table>
		<p>在正常的情况下，历史命令的读取与记录是这样的：</p>
		<ul>
		<li>当我们以 bash 登录 Linux 主机之后，系统会主动的由家目录的 ~/.bash_history
		读取以前曾经下过的指令，那么 ~/.bash_history 会记录几笔数据呢？这就与你 bash 的
		HISTFILESIZE 这个变量设置值有关了！<br><br></li>
		<li>假设我这次登录主机后，共下达过 100 次指令，『<span class="text_import2">等我注销时，
		系统就会将 101~1100 这总共 1000 笔历史命令<b>更新</b>到 ~/.bash_history 当中。</span>』
		也就是说，历史命令在我注销时，会将最近的 HISTFILESIZE 笔记录到我的纪录档当中啦！<br><br></li>
		<li>当然，也可以用 history -w 强制立刻写入的！那为何用『更新』两个字呢？
		因为 ~/.bash_history 记录的笔数永远都是 HISTFILESIZE 那么多，旧的消息会被主动的拿掉！
		仅保留最新的！</li></ul>
		<p>那么 history 这个历史命令只可以让我查找命令而已吗？呵呵！当然不止啊！
		我们可以利用相关的功能来帮我们运行命令呢！举例来说啰：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">!number</span>
[dmtsai@study ~]$ <span class="term_command">!command</span>
[dmtsai@study ~]$ <span class="term_command">!!</span>
<span class="term_say">选项与参数：
number  ：运行第几笔指令的意思；
command ：由最近的指令向前搜索『指令串开头为 command』的那个指令，并运行；
!!      ：就是运行上一个指令(相当于按↑按键后，按 Enter)</span>
[dmtsai@study ~]$ <span class="term_command">history</span>
   66  man rm
   67  alias
   68  man history
   69  history 
[dmtsai@study ~]$ <span class="term_command">!66</span>  <span class="term_note">&lt;==运行第 66 笔指令</span>
[dmtsai@study ~]$ <span class="term_command">!! </span>  <span class="term_note">&lt;==运行上一个指令，本例中亦即 !66 </span>
[dmtsai@study ~]$ <span class="term_command">!al</span>  <span class="term_note">&lt;==运行最近以 al 为开头的指令(上头列出的第 67 个)</span>
</pre></td></tr></tbody></table>
		<p>经过上面的介绍，瞭乎？历史命令用法可多了！如果我想要运行上一个指令，
		除了使用上下键之外，我可以直接以『 !! 』 来下达上个指令的内容，此外，
		我也可以直接选择下达第 n 个指令，『 !n 』来运行，也可以使用指令标头，例如
		『 !vi 』来运行最近指令开头是 vi 的指令列！相当的方便而好用！</p>
		<p>基本上 history 的用途很大的！但是需要小心安全的问题！尤其是 root 的历史纪录文件，这是
		Cracker 的最爱！因为不小心的 root 会将很多的重要数据在运行的过程中会被纪录在
		~/.bash_history 当中，如果这个文件被解析的话，后果不堪呐！无论如何，使用 history 配合『
		! 』曾经使用过的指令下达是很有效率的一个指令下达方法！</p>
		<ul class="toplist"><li>同一帐号同时多次登录的 history 写入问题</li></ul>
		<p>有些朋友在练习 linux 的时候喜欢同时开好几个 bash 接口，这些 bash 的身份都是 root 。
		这样会有 ~/.bash_history 的写入问题吗？想一想，因为这些 bash 在同时以 root 的身份登录，
		因此所有的 bash 都有自己的 1000 笔记录在内存中。因为等到注销时才会更新记录档，所以啰，
		最后注销的那个 bash 才会是最后写入的数据。唔！如此一来其他 bash 的指令操作就不会被记录下来了
		(其实有被记录，只是被后来的最后一个 bash 所覆盖更新了) 。</p>
		<p>由于多重登录有这样的问题，所以很多朋友都习惯单一 bash 登录，再用<a href="0440processcontrol.html#background">工作控制 (job control, 第四篇会介绍)</a> 来切换不同工作！
		这样才能够将所有曾经下达过的指令记录下来，也才方便未来系统管理员进行指令的 debug 啊！</p>
		<ul class="toplist"><li>无法记录时间</li></ul>
		<p>历史命令还有一个问题，那就是无法记录指令下达的时间。由于这 1000 笔历史命令是依序记录的，
		但是并没有记录时间，所以在查找方面会有一些不方便。如果读者们有兴趣，其实可以透过 ~/.bash_logout 
		来进行 history 的记录，并加上 date 来增加时间参数，也是一个可以应用的方向喔！
		有兴趣的朋友可以先看看情境仿真题一吧！</p>
		<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">		鸟哥经常需要设计在线题目给学生考试用，所以需要登录系统去设计环境，设计完毕后再将该硬盘分派给学生来考试使用。
		只是，经常很担心同学不小心输入 history 就会得知鸟哥要考试的重点文件与指令，因此就得要使用 history -c; history -w 来强迫更新纪录档了！
		提供给您参考！
		</fieldset><br>	<br></div>
</div>
<a id="settings"></a>
<div class="block1">
<h2>10.4 Bash Shell 的操作环境：</h2>
	<p>是否记得我们登录主机的时候，屏幕上头会有一些说明文本，告知我们的 Linux 版本啊什么的，
	还有，登录的时候我们还可以给予用户一些消息或者欢迎文本呢。此外，
	我们习惯的环境变量、命令别名等等的，是否可以登录就主动的帮我设置好？
	这些都是需要注意的。另外，这些设置值又可以分为系统整体设置值与各人喜好设置值，
	仅是一些文件放置的地点不同啦！这我们后面也会来谈一谈的！</p>
	<a id="settings_path"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.4.1 路径与指令搜索顺序</h2>
		<p>我们在<a href="0210filepermission.html#dir_path">第五章</a>与<a href="0220filemanager.html#dir_pathway">第六章</a>都曾谈过『相对路径与绝对路径』的关系，
		在本章的前几小节也谈到了 alias 与 bash 的内置命令。现在我们知道系统里面其实有不少的 ls 指令，
		或者是包括内置的 echo 指令，那么来想一想，如果一个指令 (例如 ls) 被下达时，
		到底是哪一个 ls 被拿来运作？很有趣吧！基本上，指令运作的顺序可以这样看：</p>
		<ol class="text_import2">
		<li>以相对/绝对路径运行指令，例如『 /bin/ls 』或『 ./ls 』；</li>
		<li>由 alias 找到该指令来运行；</li>
		<li>由 bash 内置的 (builtin) 指令来运行；</li>
		<li>透过 $PATH 这个变量的顺序搜索到的第一个指令来运行。</li>
		</ol>
		<p>举例来说，你可以下达 /bin/ls 及单纯的 ls 看看，会发现使用 ls 有颜色但是 /bin/ls 则没有颜色。
		因为 /bin/ls 是直接取用该指令来下达，而 ls 会因为『 alias ls='ls --color=auto' 』这个命令别名而先使用！
		如果想要了解指令搜索的顺序，其实透过 type -a ls 也可以查找的到啦！上述的顺序最好先了解喔！</p>
<table class="exam" style="width: 90%"><tbody><tr><td>
例题：<div>
设置 echo 的命令别名成为 echo -n ，然后再观察 echo 运行的顺序
</div>
答：<div>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">alias echo='echo -n'</span>
[dmtsai@study ~]$ <span class="term_command">type -a echo</span>
echo is aliased to `echo -n'
echo is a shell builtin
echo is /usr/bin/echo
</pre></td></tr></tbody></table>
瞧！很清楚吧！先 alias 再 builtin 再由 $PATH 找到 /bin/echo 啰！
</div>
</td></tr></tbody></table><br>
	<br></div><br>
	<a id="settings_issue"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.4.2 bash 的进站与欢迎消息： /etc/issue, /etc/motd</h2>
		<p>虾密！ bash 也有进站画面与欢迎消息喔？真假？真的啊！
		还记得在终端机接口 (tty1 ~ tty6) 登录的时候，会有几行提示的字符串吗？那就是进站画面啊！
		那个字符串写在哪里啊？呵呵！在 /etc/issue 里面啊！先来看看：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cat /etc/issue</span>
\S
Kernel \r on an \m
</pre></td></tr></tbody></table>
		<p>鸟哥是以完全未更新过的 CentOS 7.1 作为范例，里面缺省有三行，较有趣的地方在于 \r 与 \m。
		就如同 $PS1 这变量一样，issue 这个文件的内容也是可以使用反斜线作为变量取用喔！你可以 man issue 配合 
		man agetty 得到底下的结果：</p>
<table class="news" style="width: 80%">
<tbody><tr class="theader"><td>issue 内的各代码意义</td></tr>
<tr><td style="font-family:&#39;细明体&#39;">\d 本地端时间的日期；<br>
\l 显示第几个终端机接口；<br>
\m 显示硬件的等级 (i386/i486/i586/i686...)；<br>
\n 显示主机的网络名称；<br>
\O 显示 domain name；<br>
\r 操作系统的版本 (相当于 uname -r)<br>
\t 显示本地端时间的时间；<br>
\S 操作系统的名称；<br>
\v 操作系统的版本。</td></tr>
</tbody></table>
		<p>做一下底下这个练习，看看能不能取得你要的进站画面？</p>
<table class="exam"><tbody><tr><td>
例题：<div>
如果你在 tty3 的进站画面看到如下显示，该如何设置才能得到如下画面？
<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
CentOS Linux 7 (Core) (terminal: tty3)<br>
Date: 2015-07-08 17:29:19<br>
Kernel 3.10.0-229.el7.x86_64 on an x86_64<br>
Welcome!<br>
<br>
</blockquote>注意，tty3 在不同的 tty 有不同显示，日期则是再按下 [enter] 后就会所有不同。
</div>
答：<div>
很简单，用 root 的身份，并参考上述的反斜线功能去修改 /etc/issue 成为如下模样即可(共五行)：
<table class="term"><tbody><tr><td class="term"><pre><span class="term_write">\S (terminal: \l)
Date: \d \t
Kernel \r on an \m
Welcome!
</span>
</pre></td></tr></tbody></table>
曾有鸟哥的学生在这个 /etc/issue 内修改数据，光是利用简单的英文本母作出属于他自己的进站画面，
画面里面有他的中文名字呢！非常厉害！也有学生做成类似很大一个『囧』在进站画面，都非常有趣！
</div>
</td></tr></tbody></table>
		<p>你要注意的是，除了 /etc/issue 之外还有个 /etc/issue.net 呢！这是啥？这个是提供给 telnet 这个远程登录程序用的。
		当我们使用 telnet 连接到主机时，主机的登录画面就会显示 /etc/issue.net 而不是 /etc/issue 呢！</p>
		<p>至于如果<span class="text_import2">您想要让用户登录后取得一些消息，例如您想要让大家都知道的消息，
		那么可以将消息加入 /etc/motd 里面去</span>！例如：当登录后，告诉登录者，
		系统将会在某个固定时间进行维护工作，可以这样做 (一定要用 root 的身份才能修改喔！)：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">vim /etc/motd</span>
<span class="term_write">Hello everyone,
Our server will be maintained at 2015/07/10 0:00 ~ 24:00.
Please don't login server at that time. ^_^</span>
</pre></td></tr></tbody></table>
		<p>那么当你的用户(包括所有的一般帐号与 root)登录主机后，就会显示这样的消息出来：</p>
<table class="term"><tbody><tr><td class="term"><pre>Last login: Wed Jul  8 23:22:25 2015 from 127.0.0.1
Hello everyone,
Our server will be maintained at 2015/07/10 0:00 ~ 24:00.
Please don't login server at that time. ^_^
</pre></td></tr></tbody></table><br>
	<br></div><br>
	<a id="settings_bashrc"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.4.3 bash 的环境设置档</h2>
		<p>你是否会觉得奇怪，怎么我们什么动作都没有进行，但是一进入 bash 就取得一堆有用的变量了？
		这是因为系统有一些环境设置文件的存在，让 bash 在启动时直接读取这些设置档，以规划好 bash 的操作环境啦！
		而这些设置档又可以分为全体系统的设置档以及用户个人偏好设置档。要注意的是，
		我们前几个小节谈到的命令别名啦、自订的变量啦，在你注销 bash 后就会失效，所以你想要保留你的设置，
		就得要将这些设置写入设置档才行。底下就让我们来聊聊吧！</p>
		<a id="settings_bashrc_shell"></a>
		<ul class="toplist"><li>login 与 non-login shell</li></ul>
		<p>在开始介绍 bash 的设置档前，我们一定要先知道的就是 login shell 与 non-login shell！
		重点在于有没有登录 (login) 啦！</p>
		<ul class="text_import2">
		<li>login shell：取得 bash 时需要完整的登录流程的，就称为 login shell。举例来说，你要由 tty1 ~ tty6 
		登录，需要输入用户的帐号与密码，此时取得的 bash 就称为『 login shell 』啰；<br><br></li>
		<li>non-login shell：取得 bash 接口的方法不需要重复登录的举动，举例来说，(1)你以 X window 登录 Linux 后，
		再以 X 的图形化接口启动终端机，此时那个终端接口并没有需要再次的输入帐号与密码，那个 bash 的环境就称为
		non-login shell了。(2)你在原本的 bash 环境下再次下达 bash 这个指令，同样的也没有输入帐号密码，
		那第二个 bash (子进程) 也是 non-login shell 。</li>
		</ul>
		<p>为什么要介绍 login, non-login shell 呢？这是因为这两个取得 bash 的情况中，读取的设置档数据并不一样所致。
		由于我们需要登录系统，所以先谈谈 login shell 会读取哪些设置档？一般来说，login shell 其实只会读取这两个设置档：</p>
		<ol class="text_import2">
		<li>/etc/profile：这是系统整体的设置，你最好不要修改这个文件；</li>
		<li>~/.bash_profile 或 ~/.bash_login 或 ~/.profile：属于用户个人设置，你要改自己的数据，就写入这里！</li>
		</ol>
		<p>那么，就让我们来聊一聊这两个文件吧！这两个文件的内容可是非常繁复的喔！</p>
		<a id="settings_bashrc_profile"></a>
		<ul class="toplist"><li>/etc/profile (login shell 才会读)</li></ul>
		<p>你可以使用 vim 去阅读一下这个文件的内容。这个设置档可以利用用户的识别码 (UID) 来决定很多重要的变量数据，
		这也是<span class="text_import2">每个用户登录取得 bash 时一定会读取的设置档</span>！
		所以如果你想要帮所有用户设置整体环境，那就是改这里啰！不过，没事还是不要随便改这个文件喔
		这个文件设置的变量主要有：</p>
		<ul class="text_import2">
		<li>PATH：会依据 UID 决定 PATH 变量要不要含有 sbin 的系统指令目录；</li>
		<li>MAIL：依据帐号设置好用户的 mailbox 到 /var/spool/mail/帐号名；</li>
		<li>USER：根据用户的帐号设置此一变量内容；</li>
		<li>HOSTNAME：依据主机的 hostname 指令决定此一变量内容；</li>
		<li>HISTSIZE：历史命令记录笔数。CentOS 7.x 设置为 1000 ；</li>
		<li>umask：包括 root 缺省为 022 而一般用户为 002 等！</li>
		</ul>
		<p>/etc/profile 可不止会做这些事而已，他还会去调用外部的设置数据喔！在 CentOS 7.x 缺省的情况下，底下这些数据会依序的被调用进来：</p>
		<div class="illus">
		<ul><li>/etc/profile.d/*.sh</li></ul>
		<p>其实这是个目录内的众多文件！只要在 /etc/profile.d/ 这个目录内且扩展名为 .sh ，另外，用户能够具有 r 的权限，
		那么该文件就会被 /etc/profile 调用进来。在 CentOS 7.x 中，这个目录底下的文件规范了 bash 操作接口的颜色、
		语系、ll 与 ls 指令的命令别名、vi 的命令别名、which 的命令别名等等。如果你需要帮所有用户设置一些共用的命令别名时，
		可以在这个目录底下自行创建扩展名为 .sh 的文件，并将所需要的数据写入即可喔！</p>
		<ul><li>/etc/locale.conf</li></ul>
		<p>这个文件是由 /etc/profile.d/lang.sh 调用进来的！这也是我们决定 bash 缺省使用何种语系的重要设置档！
		文件里最重要的就是 LANG/LC_ALL 这些个变量的设置啦！我们在前面的 <a href="0320bash.html#variable_locale">locale</a> 讨论过这个文件啰！
		自行回去瞧瞧先！</p>
		<ul><li>/usr/share/bash-completion/completions/*</li></ul>
		<p>记得我们上头谈过 [tab] 的妙用吧？除了命令补齐、文件名补齐之外，还可以进行指令的选项/参数补齐功能！那就是从这个目录里面找到相对应的指令来处理的！
		其实这个目录底下的内容是由 /etc/profile.d/bash_completion.sh 这个文件加载的啦！</p>
		</div>
		<p>反正你只要记得，<span class="text_import2">bash 的 login shell 情况下所读取的整体环境设置档其实只有 
		/etc/profile</span>，但是 /etc/profile 还会调用出其他的设置档，所以让我们的 bash 操作接口变的非常的友善啦！
		接下来，让我们来瞧瞧，那么个人偏好的设置档又是怎么回事？</p>
		<a id="settings_bashrc_bash_profile"></a>
		<ul class="toplist"><li>~/.bash_profile (login shell 才会读) </li></ul>
		<p>bash 在读完了整体环境设置的 /etc/profile 并借此调用其他设置档后，接下来则是会读取用户的个人设置档。
		在 login shell 的 bash 环境中，所读取的个人偏好设置档其实主要有三个，依序分别是：</p>
		<ol class="text_import2">
		<li>~/.bash_profile</li>
		<li>~/.bash_login</li>
		<li>~/.profile</li>
		</ol>
		<p><span class="text_import2">其实 bash 的 login shell 设置只会读取上面三个文件的其中一个，
		而读取的顺序则是依照上面的顺序。</span>也就是说，如果 ~/.bash_profile 存在，那么其他两个文件不论有无存在，都不会被读取。
		如果 ~/.bash_profile 不存在才会去读取 ~/.bash_login，而前两者都不存在才会读取 ~/.profile 的意思。
		会有这么多的文件，其实是因应其他 shell 转换过来的用户的习惯而已。
		先让我们来看一下 dmtsai 的 /home/dmtsai/.bash_profile 的内容是怎样呢？</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cat ~/.bash_profile</span>
# .bash_profile
# Get the aliases and functions
if [ -f ~/.bashrc ]; then    <span class="term_note">&lt;==底下这三行在判断并读取 ~/.bashrc</span>
        <span class="term_write">. ~/.bashrc</span>
fi
# User specific environment and startup programs
<span class="term_write">PATH=$PATH:$HOME/.local/bin:$HOME/bin    <span class="term_note">&lt;==底下这几行在处理个人化设置</span>
export PATH</span>
</pre></td></tr></tbody></table>
		<p>这个文件内有设置 PATH 这个变量喔！而且还使用了 export 将 PATH 变成环境变量呢！
		由于 PATH 在 /etc/profile 当中已经设置过，所以在这里就以累加的方式增加用户家目录下的 ~/bin/ 
		为额外的运行档放置目录。这也就是说，你可以将自己创建的运行档放置到你自己家目录下的 ~/bin/ 目录啦！
		那就可以直接运行该运行档而不需要使用绝对/相对路径来运行该文件。</p>
		<p>这个文件的内容比较有趣的地方在于 if ... then ... 那一段！那一段代码我们会在<a href="0340bashshell-scripts.html">第十二章 shell script</a> 谈到，假设你现在是看不懂的。
		该段的内容指的是『<span class="text_import2">判断家目录下的 ~/.bashrc 存在否，若存在则读入 ~/.bashrc 的设置</span>』。
		bash 设置档的读入方式比较有趣，主要是透过一个指令『 source 』来读取的！
		也就是说 ~/.bash_profile 其实会再调用 ~/.bashrc 的设置内容喔！最后，我们来看看整个 login shell
		的读取流程：</p>
	<a id="fig10.4.1"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/centos7_bashrc_1.gif" alt="login shell 的设置档读取流程" title="login shell 的设置档读取流程" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.4.1、login shell 的设置档读取流程</div>
		<p>实线的的方向是主线流程，虚线的方向则是被调用的设置档！从上面我们也可以清楚的知道，在 CentOS 
		的 login shell 环境下，最终被读取的设置档是『 ~/.bashrc 』这个文件喔！所以，你当然可以将自己的偏好设置写入该文件即可。
		底下我们还要讨论一下 source 与 ~/.bashrc 喔！</p>
		<a id="source"></a>
		<ul class="toplist"><li>source ：读入环境设置档的指令</li></ul>
		<p>由于 /etc/profile 与 ~/.bash_profile 都是在取得 login shell 的时候才会读取的设置档，所以，
		如果你将自己的偏好设置写入上述的文件后，通常都是得注销再登录后，该设置才会生效。那么，能不能直接读取设置档而不注销登录呢？
		可以的！那就得要利用 source 这个指令了！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">source 设置档文件名</span>
<span class="term_hd">范例：将家目录的 ~/.bashrc 的设置读入目前的 bash 环境中</span>
[dmtsai@study ~]$ <span class="term_command">source ~/.bashrc</span>  <span class="term_note">&lt;==底下这两个指令是一样的！</span>
[dmtsai@study ~]$ <span class="term_command"> .  ~/.bashrc</span>
</pre></td></tr></tbody></table>
		<p>利用 source 或小数点 (.) 都可以将设置档的内容读进来目前的 shell 环境中！
		举例来说，我修改了 ~/.bashrc ，那么不需要注销，立即以 source ~/.bashrc 
		就可以将刚刚最新设置的内容读进来目前的环境中！很不错吧！还有，包括 ~/bash_profile 以及 /etc/profile 的设置中，
		很多时候也都是利用到这个 source (或小数点) 的功能喔！</p>
		<p>有没有可能会使用到不同环境设置档的时候？有啊！
		最常发生在一个人的工作环境分为多种情况的时候了！举个例子来说，在鸟哥的大型主机中，
		常常需要负责两到三个不同的案子，每个案子所需要处理的环境变量订定并不相同，
		那么鸟哥就将这两三个案子分别编写属于该案子的环境变量设置文件，当需要该环境时，就直接『
		source 变量档 』，如此一来，环境变量的设置就变的更简便而灵活了！</p>
		<a id="settings_bashrc_bashrc"></a>
		<ul class="toplist"><li>~/.bashrc (non-login shell 会读)</li></ul>
		<p>谈完了 login shell 后，那么 non-login shell 这种非登录情况取得 bash 操作接口的环境设置档又是什么？
		当你取得 non-login shell 时，该 bash 设置档仅会读取 ~/.bashrc 而已啦！那么缺省的 ~/.bashrc 内容是如何？</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">cat ~/.bashrc</span>
# .bashrc
# User specific aliases and functions
alias rm='rm -i'             <span class="term_note">&lt;==用户的个人设置</span>
alias cp='cp -i'
alias mv='mv -i'
# Source global definitions
<span class="term_write">if [ -f /etc/bashrc ]; then  <span class="term_note">&lt;==整体的环境设置</span>
        . /etc/bashrc
fi</span>
</pre></td></tr></tbody></table>
		<p>特别注意一下，由于 root 的身份与一般用户不同，鸟哥是以 root 的身份取得上述的数据，
		如果是一般用户的 ~/.bashrc 会有些许不同。看一下，你会发现在 root 的 ~/.bashrc 中其实已经规范了较为保险的命令别名了。
		此外，咱们的 CentOS 7.x 还会主动的调用 /etc/bashrc 这个文件喔！为什么需要调用 /etc/bashrc 呢？
		因为 <span class="text_import2">/etc/bashrc</span> 帮我们的 bash 定义出底下的数据：</p>
		<ul class="text_import2">
		<li>依据不同的 UID 规范出 <a href="0220filemanager.html#umask">umask</a> 的值；</li>
		<li>依据不同的 UID 规范出提示字符 (就是 PS1 变量)；</li>
		<li>调用 /etc/profile.d/*.sh 的设置</li>
		</ul>
		<p>你要注意的是，这个 /etc/bashrc 是 CentOS 特有的 (其实是 Red Hat 系统特有的)，其他不同的 distributions 
		可能会放置在不同的文件名就是了。由于这个 ~/.bashrc 会调用 /etc/bashrc 及 /etc/profile.d/*.sh ，
		所以，万一你没有 ~/.bashrc (可能自己不小心将他删除了)，那么你会发现你的 bash 提示字符可能会变成这个样子：</p>
<table class="term"><tbody><tr><td class="term"><pre>-bash-4.2$ <span class="term_white"> </span>
</pre></td></tr></tbody></table>
		<p>不要太担心啦！这是正常的，因为你并没有调用 /etc/bashrc 来规范 PS1 变量啦！而且这样的情况也不会影响你的 bash 使用。
		如果你想要将命令提示字符捉回来，那么可以复制 /etc/skel/.bashrc 到你的家目录，再修订一下你所想要的内容，
		并使用 source 去调用 ~/.bashrc ，那你的命令提示字符就会回来啦！</p>
		<ul class="toplist"><li>其他相关设置档</li></ul>
		<p>事实上还有一些设置档可能会影响到你的 bash 操作的，底下就来谈一谈：</p>
		<div class="illus">
		<a id="man"></a><ul><li>/etc/man_db.conf</li></ul>
		<p>这个文件乍看之下好像跟 bash 没相关性，但是对于系统管理员来说，
		却也是很重要的一个文件！这的文件的内容『<span class="text_import2">规范了使用
		<a href="0160startlinux.html#manual_man">man</a> 的时候， man page 
		的路径到哪里去寻找！</span>』所以说的简单一点，这个文件规定了下达
		man 的时候，该去哪里查看数据的路径设置！</p>
		<p>那么什么时候要来修改这个文件呢？如果你是以
		tarball 的方式来安装你的数据，那么你的 man page 可能会放置在
		/usr/local/softpackage/man 里头，那个 softpackage 是你的套件名称，
		这个时候你就得以手动的方式将该路径加到 /etc/man_db.conf 里头，否则使用 man 
		的时候就会找不到相关的说明档啰。</p>
		<ul><li>~/.bash_history</li></ul>
		<p>还记得我们在<a href="0320bash.html#history">历史命令</a>提到过这个文件吧？缺省的情况下，
		我们的历史命令就记录在这里啊！而这个文件能够记录几笔数据，则与 HISTFILESIZE
		这个变量有关啊。每次登录 bash 后，bash 会先读取这个文件，将所有的历史指令读入内存，
		因此，当我们登录 bash 后就可以查知上次使用过哪些指令啰。至于更多的历史指令，
		请自行回去参考喔！</p>
		<ul><li>~/.bash_logout</li></ul>
		<p>这个文件则记录了『<span class="text_import2">当我注销 bash 后，系统再帮我做完什么动作后才离开</span>』的意思。
		你可以去读取一下这个文件的内容，缺省的情况下，注销时， bash 只是帮我们清掉屏幕的消息而已。
		不过，你也可以将一些备份或者是其他你认为重要的工作写在这个文件中 (例如清空暂存盘)，
		那么当你离开 Linux 的时候，就可以解决一些烦人的事情啰！</p>
		</div>
	<br></div><br>
	<a id="settings_set"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.4.4 终端机的环境设置： stty, set</h2>
		<p>我们在<a href="0160startlinux.html">第四章首次登录 Linux</a> 时就提过，可以在 tty1 ~ tty6 
		这六个文本接口的终端机 (terminal) 环境中登录，登录的时候我们可以取得一些字符设置的功能喔！
		举例来说，我们可以利用倒退键 (backspace，就是那个←符号的按键) 来删除命令行上的字符，
		也可以使用 [ctrl]+c 来强制终止一个指令的运行，当输入错误时，就会有声音跑出来警告。这是怎么办到的呢？
		很简单啊！因为登录终端机的时候，会自动的取得一些终端机的输入环境的设置啊！</p>
		<p>事实上，目前我们使用的 Linux distributions 都帮我们作了最棒的用户环境了，
		所以大家可以不用担心操作环境的问题。不过，在某些 Unix like 的机器中，还是可能需要动用一些手脚，
		才能够让我们的输入比较快乐～举例来说，利用 [backspace] 删除，要比利用 [Del] 按键来的顺手吧！
		但是某些 Unix 偏偏是以 [del] 来进行字符的删除啊！所以，这个时候就可以动动手脚啰～</p>
		<p>那么如何查阅目前的一些按键内容呢？可以利用 stty (setting tty 终端机的意思) 呢！
		stty 也可以帮助设置终端机的输入按键代表意义喔！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">stty [-a]</span>
<span class="term_say">选项与参数：
-a  ：将目前所有的 stty 参数表出来；</span>
<span class="term_hd">范例一：列出所有的按键与按键内容</span>
[dmtsai@study ~]$ <span class="term_command">stty -a</span>
speed 38400 baud; rows 20; columns 90; line = 0;
<span class="term_write">intr = ^C</span>; quit = ^\; <span class="term_write">erase = ^?</span>; kill = ^U; <span class="term_write">eof = ^D</span>; eol = &lt;undef&gt;; eol2 = &lt;undef&gt;;
swtch = &lt;undef&gt;; <span class="term_write">start = ^Q</span>; <span class="term_write">stop = ^S</span>; <span class="term_write">susp = ^Z</span>; rprnt = ^R; werase = ^W; lnext = ^V;
flush = ^O; min = 1; time = 0;
<span class="term_say">....(以下省略)....</span>
</pre></td></tr></tbody></table>
		<p>我们可以利用 stty -a 来列出目前环境中所有的按键列表，在上头的列表当中，需要注意的是特殊字体那几个，
		此外，<span class="text_import2">如果出现 ^ 表示 [Ctrl] 那个按键的意思</span>。举例来说， intr = ^C 
		表示利用 [ctrl] + c 来达成的。几个重要的代表意义是：</p>
		<ul style="font-family:&#39;细明体&#39;">
		<li>intr &nbsp;: 送出一个 interrupt (中断) 的信号给目前正在 run 的进程 (就是终止啰！)；</li>
		<li>quit&nbsp; : 送出一个 quit 的信号给目前正在 run 的进程；</li>
		<li>erase : 向后删除字符，</li>
		<li class="text_import2">kill &nbsp;: 删除在目前指令列上的所有文本；</li>
		<li>eof &nbsp;&nbsp;: End of file 的意思，代表『结束输入』。</li>
		<li class="text_import2">start : 在某个进程停止后，重新启动他的 output</li>
		<li class="text_import2">stop &nbsp;: 停止目前屏幕的输出；</li>
		<li>susp &nbsp;: 送出一个 terminal stop 的信号给正在 run 的进程。</li>
		</ul>
		<p>记不记得我们在<a href="0160startlinux.html#cmd_hkey">第四章讲过几个 Linux 热键</a>啊？没错！
		就是这个 stty 设置值内的 intr([ctrl]+c) / eof([ctrl]+d) 啰～至于删除字符，就是 erase 那个设置值啦！
		如果你想要用 [ctrl]+h 来进行字符的删除，那么可以下达：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">stty erase ^h</span>  <span class="term_note"># 这个设置看看就好，不必真的实做！不然还要改回来！</span>
</pre></td></tr></tbody></table>
		<p>那么从此之后，你的删除字符就得要使用 [ctrl]+h 啰，按下 [backspace] 则会出现 ^? 字样呢！
		如果想要回复利用 [backspace] ，就下达 <span class="text_import2">stty erase ^?</span> 即可啊！
		至于更多的 stty 说明，记得参考一下 man stty 的内容喔！</p>
<table class="exam"><tbody><tr><td>
问：<div>
因为鸟哥的工作经常在 Windows/Linux 之间切换，在 windows 底下，很多软件缺省的保存快捷按钮是 [ctrl]+s ，所以鸟哥习惯按这个按钮来处理。
不过，在 Linux 底下使用 vim 时，却也经常不小心就按下 [ctrl]+s ！问题来了，按下这个组合钮之后，整个 vim 就不能动了 (整个画面锁死)！
请问鸟哥该如何处置？</div>
答：<div>
参考一下 stty -a 的输出中，有个 stop 的项目就是按下 [ctrl]+s 的！那么恢复成 start 就是 [ctrl]+q 啊！因此，
尝试按下 [ctrl]+q 应该就可以让整个画面重新恢复正常咯！
</div>
</td></tr></tbody></table>
		<p>除了 stty 之外，其实我们的 bash 还有自己的一些终端机设置值呢！那就是利用 set 来设置的！
		我们之前提到一些变量时，可以利用 set 来显示，除此之外，其实 set 还可以帮我们设置整个指令输出/输入的环境。
		例如记录历史命令、显示错误内容等等。</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">set [-uvCHhmBx]</span>
<span class="term_say">选项与参数：
-u  ：缺省不启用。若启用后，当使用未设置变量时，会显示错误消息；
-v  ：缺省不启用。若启用后，在消息被输出前，会先显示消息的原始内容；
-x  ：缺省不启用。若启用后，在指令被运行前，会显示指令内容(前面有 ++ 符号)
-h  ：缺省启用。与历史命令有关；
-H  ：缺省启用。与历史命令有关；
-m  ：缺省启用。与工作管理有关；
-B  ：缺省启用。与刮号 [] 的作用有关；
-C  ：缺省不启用。若使用 &gt; 等，则若文件存在时，该文件不会被覆盖。</span>
<span class="term_hd">范例一：显示目前所有的 set 设置值</span>
[dmtsai@study ~]$ <span class="term_command">echo $-</span>
himBH
<span class="term_say"># 那个 $- 变量内容就是 set 的所有设置啦！ bash 缺省是 himBH 喔！</span>
<span class="term_hd">范例二：设置 "若使用未定义变量时，则显示错误消息" </span>
[dmtsai@study ~]$ <span class="term_command">set -u</span>
[dmtsai@study ~]$ <span class="term_command">echo $vbirding</span>
-bash: vbirding: unbound variable
<span class="term_say"># 缺省情况下，未设置/未声明 的变量都会是『空的』，不过，若设置 -u 参数，
# 那么当使用未设置的变量时，就会有问题啦！很多的 shell 都缺省启用 -u 参数。
# 若要取消这个参数，输入 set +u 即可！</span>
<span class="term_hd">范例三：运行前，显示该指令内容。</span>
[dmtsai@study ~]$ <span class="term_command">set -x</span>
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'    <span class="term_note"># 这个是在列出提示字符的控制码！</span>
[dmtsai@study ~]$ <span class="term_command">echo ${HOME}</span>
+ echo /home/dmtsai
/home/dmtsai
++ printf '\033]0;%s@%s:%s\007' dmtsai study '~'
<span class="term_say"># 看见否？要输出的指令都会先被打印到屏幕上喔！前面会多出 + 的符号！</span>
</pre></td></tr></tbody></table>
		<p>另外，其实我们还有其他的按键设置功能呢！就是在前一小节提到的 /etc/inputrc 这个文件里面设置。
		还有例如 /etc/DIR_COLORS* 与 /usr/share/terminfo/* 等，也都是与终端机有关的环境设置文件呢！
		不过，事实上，鸟哥并不建议您修改 tty 的环境呢，这是因为 bash 的环境已经设置的很亲和了，
		我们不需要额外的设置或者修改，否则反而会产生一些困扰。不过，写在这里的数据，
		只是希望大家能够清楚的知道我们的终端机是如何进行设置的喔！ ^_^！
		最后，我们将 bash 缺省的组合键给他汇整如下：</p>
<table class="news" style="width: 90%">
<tbody><tr class="theader"><td>组合按键</td><td>运行结果</td></tr>
<tr><td>Ctrl + C</td><td>终止目前的命令</td></tr>
<tr><td>Ctrl + D</td><td>输入结束 (EOF)，例如邮件结束的时候；</td></tr>
<tr><td>Ctrl + M</td><td>就是 Enter 啦！</td></tr>
<tr><td>Ctrl + S</td><td>暂停屏幕的输出</td></tr>
<tr><td>Ctrl + Q</td><td>恢复屏幕的输出</td></tr>
<tr><td>Ctrl + U</td><td>在提示字符下，将整列命令删除</td></tr>
<tr><td>Ctrl + Z</td><td>『暂停』目前的命令</td></tr>
</tbody></table><br>
	<br></div><br>
	<a id="settings_wildcard"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.4.5 通配符与特殊符号</h2>
		<p>在 bash 的操作环境中还有一个非常有用的功能，那就是通配符 (wildcard) ！
		我们利用 bash 处理数据就更方便了！底下我们列出一些常用的通配符喔：</p>
<table class="news" style="width: 95%">
<tbody><tr class="theader"><td style="width: 50px">符号</td><td>意义</td></tr>
<tr><td class="tcenter">*</td><td>代表『 0 个到无穷多个』任意字符</td></tr>
<tr><td class="tcenter">?</td><td>代表『一定有一个』任意字符</td></tr>
<tr><td class="tcenter">[  ]</td><td>同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符，
	可能是 a, b, c, d 这四个任何一个』</td></tr>
<tr><td class="tcenter">[ - ]</td><td>若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表
	0 到 9 之间的所有数字，因为数字的语系编码是连续的！</td></tr>
<tr><td class="tcenter">[^ ]</td><td>若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表
	一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思。</td></tr>
</tbody></table>
		<p>接下来让我们利用通配符来玩些东西吧！首先，利用通配符配合 ls 找文件名看看：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">LANG=C            </span>  <span class="term_note">&lt;==由于与编码有关，先设置语系一下</span>
<span class="term_hd">范例一：找出 /etc/ 底下以 cron 为开头的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/cron*  </span>  <span class="term_note">&lt;==加上 -d 是为了仅显示目录而已</span>
<span class="term_hd">范例二：找出 /etc/ 底下文件名『刚好是五个字母』的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/?????  </span>  <span class="term_note">&lt;==由于 ? 一定有一个，所以五个 ? 就对了</span>
<span class="term_hd">范例三：找出 /etc/ 底下文件名含有数字的文件名</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/*[0-9]*</span>  <span class="term_note">&lt;==记得中括号左右两边均需 *</span>
<span class="term_hd">范例四：找出 /etc/ 底下，文件名开头非为小写字母的文件名：</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /etc/[^a-z]*</span>  <span class="term_note">&lt;==注意中括号左边没有 *</span>
<span class="term_hd">范例五：将范例四找到的文件复制到 /tmp/upper 中</span>
[dmtsai@study ~]$ <span class="term_command">mkdir /tmp/upper; cp -a /etc/[^a-z]* /tmp/upper</span>
</pre></td></tr></tbody></table>
		<p>除了通配符之外，bash 环境中的特殊符号有哪些呢？底下我们先汇整一下：</p>
<table class="news" style="width: 95%">
<tbody><tr class="theader"><td style="width: 60px">符号</td><td>内容</td></tr>
<tr><td class="tcenter">#</td><td>注解符号：这个最常被使用在 script 当中，视为说明！在后的数据均不运行</td></tr>
<tr><td class="tcenter">\</td><td>跳脱符号：将『特殊字符或通配符』还原成一般字符</td></tr>
<tr><td class="tcenter">|</td><td>管线 (pipe)：分隔两个管线命令的界定(后两节介绍)；</td></tr>
<tr><td class="tcenter">;</td><td>连续指令下达分隔符号：连续性命令的界定 (注意！与管线命令并不相同)</td></tr>
<tr><td class="tcenter">~</td><td>用户的家目录</td></tr>
<tr><td class="tcenter">$</td><td>取用变量前置字符：亦即是变量之前需要加的变量取代值</td></tr>
<tr><td class="tcenter">&amp;</td><td>工作控制 (job control)：将指令变成背景下工作</td></tr>
<tr><td class="tcenter">!</td><td>逻辑运算意义上的『非』 not 的意思！</td></tr>
<tr><td class="tcenter">/</td><td>目录符号：路径分隔的符号</td></tr>
<tr><td class="tcenter">&gt;, &gt;&gt;</td><td>数据流重导向：输出导向，分别是『取代』与『累加』</td></tr>
<tr><td class="tcenter">&lt;, &lt;&lt;</td><td>数据流重导向：输入导向 (这两个留待下节介绍)</td></tr>
<tr><td class="tcenter">' '</td><td>单引号，不具有变量置换的功能 ($ 变为纯文本)</td></tr>
<tr><td class="tcenter">" "</td><td>具有变量置换的功能！ ($ 可保留相关功能)</td></tr>
<tr><td class="tcenter">` `</td><td>两个『 ` 』中间为可以先运行的指令，亦可使用 $( )</td></tr>
<tr><td class="tcenter">(   )</td><td>在中间为子 shell 的起始与结束</td></tr>
<tr><td class="tcenter">{   }</td><td>在中间为命令区块的组合！</td></tr>
</tbody></table>
		<p>以上为 bash 环境中常见的特殊符号汇整！理论上，你的『文件名』尽量不要使用到上述的字符啦！</p>
	<br></div>
</div>
<a id="redirect"></a>
<div class="block1">
<h2>10.5 数据流重导向</h2>
	<p>数据流重导向 (redirect) 由字面上的意思来看，好像就是将『数据给他传导到其他地方去』的样子？
	没错～数据流重导向就是将某个指令运行后应该要出现在屏幕上的数据，
	给他传输到其他的地方，例如文件或者是设备 (例如打印机之类的)！这玩意儿在 Linux 的文本模式底下可重要的！
	尤其是如果我们想要将某些数据保存下来时，就更有用了！</p>
	<a id="redirect_redirect"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.5.1 什么是数据流重导向</h2>
		<p>什么是数据流重导向啊？这得要由指令的运行结果谈起！一般来说，如果你要运行一个指令，通常他会是这样的：</p>
	<a id="fig10.5.1"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/centos7_redirection.jpg" alt="指令运行过程的数据传输情况" title="指令运行过程的数据传输情况" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.5.1、指令运行过程的数据传输情况</div>
		<p>我们运行一个指令的时候，这个指令可能会由文件读入数据，经过处理之后，再将数据输出到屏幕上。
		在上图当中， standard output 与 standard error output 分别代表『标准输出 (STDOUT)』与『标准错误输出 (STDERR)』，
		这两个玩意儿缺省都是输出到屏幕上面来的啊！那么什么是标准输出与标准错误输出呢？</p>
		<ul class="toplist"><li>standard output 与 standard error output</li></ul>
		<p>简单的说，<span class="text_import2">标准输出指的是『指令运行所回传的正确的消息』，而标准错误输出可理解为『
		指令运行失败后，所回传的错误消息』</span>。举个简单例子来说，我们的系统缺省有 /etc/crontab 但却无 /etc/vbirdsay，
		此时若下达『 cat /etc/crontab /etc/vbirdsay 』这个指令时，cat 会进行：</p>
		<ul>
		<li>标准输出：读取 /etc/crontab 后，将该文件内容显示到屏幕上；</li>
		<li>标准错误输出：因为无法找到 /etc/vbirdsay，因此在屏幕上显示错误消息</li>
		</ul>
		<p>不管正确或错误的数据都是缺省输出到屏幕上，所以屏幕当然是乱乱的！那能不能透过某些机制将这两股数据分开呢？
		当然可以啊！那就是数据流重导向的功能啊！数据流重导向可以将 standard output (简称 stdout) 与 standard error
		output (简称 stderr) 分别发送到其他的文件或设备去，而分别发送所用的特殊字符则如下所示：</p>
		<ol class="text_import2" style="font-family: &#39;细明体&#39;">
		<li>标准输入　　(stdin) ：代码为 0 ，使用 &lt; 或 &lt;&lt; ；</li>
		<li>标准输出　　(stdout)：代码为 1 ，使用 &gt; 或 &gt;&gt; ；</li>
		<li>标准错误输出(stderr)：代码为 2 ，使用 2&gt; 或 2&gt;&gt; ；</li>
		</ol>
		<p>为了理解 stdout 与 stderr ，我们先来进行一个范例的练习：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：观察你的系统根目录 (/) 下各目录的文件名、权限与属性，并记录下来</span>
[dmtsai@study ~]$ <span class="term_command">ll /</span>  <span class="term_note">&lt;==此时屏幕会显示出文件名信息</span>
[dmtsai@study ~]$ <span class="term_command">ll / &gt; ~/rootfile</span> <span class="term_note">&lt;==屏幕并无任何信息</span>
[dmtsai@study ~]$ <span class="term_command">ll  ~/rootfile</span> <span class="term_note">&lt;==有个新档被创建了！</span>
-rw-rw-r--. 1 dmtsai dmtsai 1078 Jul  9 18:51 /home/dmtsai/rootfile
</pre></td></tr></tbody></table>
		<p>怪了！屏幕怎么会完全没有数据呢？这是因为原本『 ll / 』所显示的数据已经被重新导向到 ~/rootfile 文件中了！
		那个 ~/rootfile 的文件名可以随便你取。如果你下达『 cat ~/rootfile 』那就可以看到原本应该在屏幕上面的数据啰。
		如果我再次下达：『 ll /home &gt; ~/rootfile 』后，那个 ~/rootfile 文件的内容变成什么？
		他将变成『仅有 ll /home 的数据』而已！咦！原本的『 ll / 』数据就不见了吗？是的！因为该文件的创建方式是：</p>
		<ol class="text_import2">
		<li>该文件 (本例中是 ~/rootfile) 若不存在，系统会自动的将他创建起来，但是</li>
		<li>当这个文件存在的时候，那么系统就会先将这个文件内容清空，然后再将数据写入！</li>
		<li>也就是若以 &gt; 输出到一个已存在的文件中，那个文件就会被覆盖掉啰！</li>
		</ol>
		<p>那如果我想要将数据累加而不想要将旧的数据删除，那该如何是好？利用两个大于的符号 (&gt;&gt;)
		就好啦！以上面的范例来说，你应该要改成『 <span class="text_import2">ll / &gt;&gt; ~/rootfile</span> 』即可。
		如此一来，当 (1) ~/rootfile 不存在时系统会主动创建这个文件；(2)若该文件已存在，
		则数据会在该文件的最下方累加进去！</p>
		<p>上面谈到的是 standard output 的正确数据，那如果是 standard error output 的错误数据呢？那就透过 2&gt; 及
		2&gt;&gt; 啰！同样是覆盖 (2&gt;) 与累加 (2&gt;&gt;) 的特性！我们在刚刚才谈到 stdout 代码是 1 而 stderr 代码是 2 ，
		所以这个 2&gt; 是很容易理解的，而如果仅存在 &gt; 时，则代表缺省的代码 1 啰！也就是说：</p>
		<ul class="text_import2" style="font-family: &#39;细明体&#39;">
		<li>1&gt; ：以覆盖的方法将『正确的数据』输出到指定的文件或设备上；</li>
		<li>1&gt;&gt;：以累加的方法将『正确的数据』输出到指定的文件或设备上；</li>
		<li>2&gt; ：以覆盖的方法将『错误的数据』输出到指定的文件或设备上；</li>
		<li>2&gt;&gt;：以累加的方法将『错误的数据』输出到指定的文件或设备上；</li>
		</ul>
		<p>要注意喔，『 1&gt;&gt; 』以及『 2&gt;&gt; 』中间是没有空格的！OK！有些概念之后让我们继续聊一聊这家伙怎么应用吧！
		当你以一般身份运行 <a href="0220filemanager.html#find">find</a>
		这个指令的时候，由于权限的问题可能会产生一些错误信息。例如运行『 <span class="text_import2">find / -name 
		testing</span> 』时，可能会产生类似『 find: /root: Permission denied 』之类的消息。
		例如底下这个范例：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：利用一般身份帐号搜索 /home 底下是否有名为 .bashrc 的文件存在</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc</span> <span class="term_note">&lt;==身份是 dmtsai 喔！</span>
find: '/home/arod': Permission denied    <span class="term_note">&lt;== Standard error output</span>
find: '/home/alex': Permission denied    <span class="term_note">&lt;== Standard error output</span>
/home/dmtsai/.bashrc                     <span class="term_note">&lt;== Standard output</span>
</pre></td></tr></tbody></table>
		<p>由于 /home 底下还有我们之前创建的帐号存在，那些帐号的家目录你当然不能进入啊！所以就会有错误及正确数据了。
		好了，那么假如我想要将数据输出到 list 这个文件中呢？运行『 find /home -name .bashrc &gt; list 』
		会有什么结果？呵呵，你会发现 <span class="text_import2">list 里面存了刚刚那个『正确』的输出数据，
		至于屏幕上还是会有错误的消息出现呢</span>！伤脑筋！如果想要将正确的与错误的数据分别存入不同的文件中需要怎么做？</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：承范例二，将 stdout 与 stderr 分存到不同的文件去</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list_right 2&gt; list_error</span>
</pre></td></tr></tbody></table>
		<p>注意喔，此时『屏幕上不会出现任何消息』！因为刚刚运行的结果中，有 Permission 的那几行错误信息都会跑到 list_error 
		这个文件中，至于正确的输出数据则会存到 list_right 这个文件中啰！这样可以了解了吗？
		如果有点混乱的话，去休息一下再回来看看吧！</p>
		<ul class="toplist"><li>/dev/null 垃圾桶黑洞设备与特殊写法</li></ul>
		<p>想像一下，如果我知道错误消息会发生，所以要将错误消息忽略掉而不显示或保存呢？
		这个时候黑洞设备 /dev/null 就很重要了！这个 /dev/null 可以吃掉任何导向这个设备的信息喔！将上述的范例修订一下：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：承范例三，将错误的数据丢弃，屏幕上显示正确的数据</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc 2&gt; /dev/null</span>
/home/dmtsai/.bashrc  <span class="term_note">&lt;==只有 stdout 会显示到屏幕上， stderr 被丢弃了</span>
</pre></td></tr></tbody></table>
		<p>再想像一下，如果我要将正确与错误数据通通写入同一个文件去呢？这个时候就得要使用特殊的写法了！
		我们同样用底下的案例来说明：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例五：将指令的数据全部写入名为 list 的文件中</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt; list</span>  <span class="term_note">&lt;==错误</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &gt; list 2&gt;&amp;1   </span>  <span class="term_note">&lt;==正确</span>
[dmtsai@study ~]$ <span class="term_command">find /home -name .bashrc &amp;&gt; list       </span>  <span class="term_note">&lt;==正确</span>
</pre></td></tr></tbody></table>
		<p>上述表格第一行错误的原因是，<span class="text_import2">由于两股数据同时写入一个文件，又没有使用特殊的语法，
		此时两股数据可能会交叉写入该文件内，造成次序的错乱</span>。所以虽然最终 list 
		文件还是会产生，但是里面的数据排列就会怪怪的，而不是原本屏幕上的输出排序。
		至于写入同一个文件的特殊语法如上表所示，你可以使用 2&gt;&amp;1 也可以使用 &amp;&gt; ！
		一般来说，鸟哥比较习惯使用 2&gt;&amp;1 的语法啦！</p>
		<ul class="toplist"><li>standard input ： &lt; 与 &lt;&lt;</li></ul>
		<p>了解了 stderr 与 stdout 后，那么那个 &lt; 又是什么呀？呵呵！以最简单的说法来说，
		那就是『<span class="text_import2">将原本需要由键盘输入的数据，改由文件内容来取代</span>』的意思。
		我们先由底下的 cat 指令操作来了解一下什么叫做『键盘输入』吧！</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例六：利用 cat 指令来创建一个文件的简单流程</span>
[dmtsai@study ~]$ <span class="term_command">cat &gt; catfile</span>
<span class="term_command">testing
cat file test</span>
<span class="term_note">&lt;==这里按下 [ctrl]+d 来离开</span>
[dmtsai@study ~]$ <span class="term_command">cat catfile</span>
testing
cat file test
</pre></td></tr></tbody></table>
		<p>由于加入 &gt; 在 cat 后，所以那个 catfile 会被主动的创建，而内容就是刚刚键盘上面输入的那两行数据了。
		唔！那我能不能用纯文本档取代键盘的输入，也就是说，<span class="text_import2">用某个文件的内容来取代键盘的敲击呢？</span>
		可以的！如下所示：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例七：用 stdin 取代键盘的输入以创建新文件的简单流程</span>
[dmtsai@study ~]$ <span class="term_command">cat &gt; catfile &lt; ~/.bashrc</span>
[dmtsai@study ~]$ <span class="term_command">ll catfile ~/.bashrc</span>
-rw-r--r--. 1 dmtsai dmtsai <span class="term_write">231</span> Mar  6 06:06 /home/dmtsai/.bashrc
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_write">231</span> Jul  9 18:58 catfile
<span class="term_say"># 注意看，这两个文件的大小会一模一样！几乎像是使用 cp 来复制一般！</span>
</pre></td></tr></tbody></table>
		<p>这东西非常的有帮助！尤其是用在类似 mail 这种指令的使用上。
		理解 &lt; 之后，再来则是怪可怕一把的 &lt;&lt; 这个连续两个小于的符号了。
		他代表的是『结束的输入字符』的意思！举例来讲：『我要用 cat 直接将输入的消息输出到 catfile 中，
		且当由键盘输入 eof 时，该次输入就结束』，那我可以这样做：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cat &gt; catfile &lt;&lt; "eof"</span>
&gt; <span class="term_command">This is a test.</span>
&gt; <span class="term_command">OK now stop</span>
&gt; <span class="term_command">eof</span>  <span class="term_note">&lt;==输入这关键字，立刻就结束而不需要输入 [ctrl]+d</span>
[dmtsai@study ~]$ <span class="term_command">cat catfile</span>
This is a test.
OK now stop     <span class="term_note">&lt;==只有这两行，不会存在关键字那一行！</span>
</pre></td></tr></tbody></table>
		<p>看到了吗？利用 &lt;&lt; 右侧的控制字符，我们可以终止一次输入，
		而不必输入 [ctrl]+d 来结束哩！这对程序写作很有帮助喔！好了，那么为何要使用命令输出重导向呢？我们来说一说吧！</p>
		<ul class="text_import2">
		<li>屏幕输出的信息很重要，而且我们需要将他存下来的时候；</li>
		<li>背景运行中的程序，不希望他干扰屏幕正常的输出结果时；</li>
		<li>一些系统的例行命令 (例如写在 /etc/crontab 中的文件) 的运行结果，希望他可以存下来时；</li>
		<li>一些运行命令的可能已知错误消息时，想以『 2&gt; /dev/null 』将他丢掉时；</li>
		<li>错误消息与正确消息需要分别输出时。</li></ul>
		<p>当然还有很多的功能的，最简单的就是网友们常常问到的：『<span class="text_import2">为何我的 root 
		都会收到系统 crontab 寄来的错误消息呢</span>』这个咚咚是常见的错误，
		而如果我们已经知道这个错误消息是可以忽略的时候，嗯！『 2&gt; errorfile 』这个功能就很重要了吧！
		了解了吗？</p>
<table class="exam"><tbody><tr><td>
问：<div>
假设我要将 echo "error message" 以 standard error output 的格式来输出，该如何处置？
</div>
答：<div>
既然有 2&gt;&amp;1 来将 2&gt; 转到 1&gt; 去，那么应该也会有 1&gt;&amp;2 吧？没错！就是这个概念！因此你可以这样作：
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">echo "error message" 1&gt;&amp;2 </span>
[dmtsai@study ~]$ <span class="term_command">echo "error message" 2&gt; /dev/null 1&gt;&amp;2</span>
</pre></td></tr></tbody></table>
你会发现第一条有消息输出到屏幕上，第二条则没有消息！这表示该消息已经是透过 2&gt; /dev/null 丢到垃圾桶去了！
可以肯定是错误消息啰！ ^_^
</div>
</td></tr></tbody></table><br>
	<br></div><br>
	<a id="redirect_com"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.5.2 命令运行的判断依据： ; , &amp;&amp;, ||</h2>
		<p>在某些情况下，很多指令我想要一次输入去运行，而不想要分次运行时，该如何是好？基本上你有两个选择，
		一个是透过第十二章要介绍的 <a href="0340bashshell-scripts.html">shell script</a> 
		撰写脚本去运行，一种则是透过底下的介绍来一次输入多重指令喔！</p>
		<ul class="toplist"><li>cmd ; cmd (不考虑指令相关性的连续指令下达)</li></ul>
		<p>在某些时候，我们希望可以一次运行多个指令，例如在关机的时候我希望可以先运行两次 sync 同步化写入磁盘后才 shutdown 
		电脑，那么可以怎么作呢？这样做呀：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">sync; sync; shutdown -h now</span>
</pre></td></tr></tbody></table>
		<p>在指令与指令中间利用分号 (;) 来隔开，这样一来，分号前的指令运行完后就会立刻接着运行后面的指令了。
		这真是方便啊～再来，换个角度来想，万一我想要在某个目录底下创建一个文件，也就是说，如果该目录存在的话，
		那我才创建这个文件，如果不存在，那就算了。也就是说这两个指令彼此之间是有相关性的，
		前一个指令是否成功的运行与后一个指令是否要运行有关！那就得动用到 &amp;&amp; 或 || 啰！</p>
		<ul class="toplist"><li>$? (指令回传值) 与 &amp;&amp; 或 ||</li></ul>
		<p>如同上面谈到的，两个指令之间有相依性，而这个相依性主要判断的地方就在于前一个指令运行的结果是否正确。
		还记得本章之前我们曾介绍过<a href="0320bash.html#returnvar">指令回传值</a>吧！嘿嘿！没错，您真聪明！就是透过这个回传值啦！
		再复习一次『<span class="text_import2">若前一个指令运行的结果为正确，在 Linux 底下会回传一个 $? = 0 的值</span>』。
		那么我们怎么透过这个回传值来判断后续的指令是否要运行呢？这就得要借由『 &amp;&amp; 』及『 || 』的帮忙了！
		注意喔，<span class="text_import2">两个 &amp; 之间是没有空格的！那个 | 则是 [Shift]+[\] 的按键结果</span>。</p>
<table class="news" style="width: 95%">
<tbody><tr class="theader"><td>指令下达情况</td><td>说明</td></tr>
<tr><td>cmd1 &amp;&amp; cmd2</td><td>1. 若 cmd1 运行完毕且正确运行($?=0)，则开始运行 cmd2。<br>
2. 若 cmd1 运行完毕且为错误 ($?≠0)，则 cmd2 不运行。</td></tr>
<tr><td>cmd1 || cmd2</td><td>1. 若 cmd1 运行完毕且正确运行($?=0)，则 cmd2 不运行。<br>
2. 若 cmd1 运行完毕且为错误 ($?≠0)，则开始运行 cmd2。</td></tr>
</tbody></table>
		<p>上述的 cmd1 及 cmd2 都是指令。好了，回到我们刚刚假想的情况，就是想要：
		(1)先判断一个目录是否存在； (2)若存在才在该目录底下创建一个文件。由于我们尚未介绍如何判断式 (<a href="0340bashshell-scripts.html#test">test</a>) 的使用，在这里我们使用 ls 以及回传值来判断目录是否存在啦！
		让我们进行底下这个练习看看：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例一：使用 ls 查阅目录 /tmp/abc 是否存在，若存在则用 touch 创建 /tmp/abc/hehe </span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
ls: cannot access /tmp/abc: No such file or directory
<span class="term_say"># ls 很干脆的说明找不到该目录，但并没有 touch 的错误，表示 touch 并没有运行</span>
[dmtsai@study ~]$ <span class="term_command">mkdir /tmp/abc</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
[dmtsai@study ~]$ <span class="term_command">ll /tmp/abc</span>
-rw-rw-r--. 1 dmtsai dmtsai 0 Jul  9 19:16 hehe
</pre></td></tr></tbody></table>
		<p>看到了吧？如果 /tmp/abc 不存在时，touch 就不会被运行，若 /tmp/abc 存在的话，那么 touch 就会开始运行啰！
		很不错用吧！不过，我们还得手动自行创建目录，伤脑筋～能不能自动判断，如果没有该目录就给予创建呢？
		参考一下底下的例子先：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例二：测试 /tmp/abc 是否存在，若不存在则予以创建，若存在就不作任何事情</span>
[dmtsai@study ~]$ <span class="term_command">rm -r /tmp/abc               </span> <span class="term_note">&lt;==先删除此目录以方便测试</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc || mkdir /tmp/abc</span>
ls: cannot access /tmp/abc: No such file or directory  <span class="term_note">&lt;==真的不存在喔！</span>
[dmtsai@study ~]$ <span class="term_command">ll -d /tmp/abc                  </span>
drwxrwxr-x. 2 dmtsai dmtsai 6 Jul  9 19:17 /tmp/abca   <span class="term_note">&lt;==结果出现了！有进行 mkdir</span>
</pre></td></tr></tbody></table>
		<p>如果你一再重复『 ls /tmp/abc || mkdir /tmp/abc 』画面也不会出现重复 mkdir 的错误！这是因为 /tmp/abc 已经存在，
		所以后续的 mkdir 就不会进行！这样理解否？好了，让我们再次的讨论一下，如果我想要创建 /tmp/abc/hehe 这个文件，
		但我并不知道 /tmp/abc 是否存在，那该如何是好？试看看：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例三：我不清楚 /tmp/abc 是否存在，但就是要创建 /tmp/abc/hehe 文件</span>
[dmtsai@study ~]$ <span class="term_command">ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe</span>
</pre></td></tr></tbody></table>
		<p>上面这个范例三总是会尝试创建 /tmp/abc/hehe 的喔！不论 /tmp/abc 是否存在。那么范例三应该如何解释呢？
		由于<span class="text_import2">Linux 底下的指令都是由左往右运行</span>的，所以范例三有几种结果我们来分析一下：</p>
		<ul>
		<li>(1)若 /tmp/abc 不存在故回传 $?≠0，则 (2)因为 || 遇到非为 0 的 $? 故开始 mkdir /tmp/abc，由于 mkdir /tmp/abc
		会成功进行，所以回传 $?=0 (3)因为 &amp;&amp; 遇到 $?=0 故会运行 touch /tmp/abc/hehe，最终 hehe 
		就被创建了；<br><br></li>
		<li>(1)若 /tmp/abc 存在故回传 $?=0，则 (2)因为 || 遇到 0 的 $? 不会进行，此时 $?=0 继续向后传，故 
		(3)因为 &amp;&amp; 遇到 $?=0 就开始创建 /tmp/abc/hehe 了！最终 /tmp/abc/hehe 被创建起来。</li>
		</ul>
		<p>整个流程图标如下：</p>
	<a id="fig10.5.2"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/cmd_1.gif" alt="指令依序运行的关系示意图" title="指令依序运行的关系示意图" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.5.2、指令依序运行的关系示意图</div>
		<p>上面这张图显示的两股数据中，上方的线段为不存在 /tmp/abc 时所进行的指令行为，下方的线段则是存在 
		/tmp/abc 所在的指令行为。如上所述，下方线段由于存在 /tmp/abc 所以导致 $?=0 ，让中间的 mkdir 就不运行了！
		并将 $?=0 继续往后传给后续的 touch 去利用啦！瞭乎？在任何时刻你都可以拿上面这张图作为示意！
		让我们来想想底下这个例题吧！</p>
<table class="exam"><tbody><tr><td>
例题：<div>
以 ls 测试 /tmp/vbirding 是否存在，若存在则显示 "exist" ，若不存在，则显示 "not exist"！
</div>
答：<div>
这又牵涉到逻辑判断的问题，如果存在就显示某个数据，若不存在就显示其他数据，那我可以这样做：
<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
	ls /tmp/vbirding &amp;&amp; echo "exist" || echo "not exist"</blockquote>
意思是说，当 ls /tmp/vbirding 运行后，若正确，就运行 echo "exist" ，若有问题，就运行 echo "not exist" 
！那如果写成如下的状况会出现什么？
<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
	ls /tmp/vbirding || echo "not exist" &amp;&amp; echo "exist"</blockquote>
这其实是有问题的，为什么呢？由图 10.5.2 的流程介绍我们知道指令是一个一个往后运行，
因此在上面的例子当中，如果 /tmp/vbirding 不存在时，他会进行如下动作：
<ol>
<li>若 ls /tmp/vbirding 不存在，因此回传一个非为 0 的数值；</li>
<li>接下来经过 || 的判断，发现前一个指令回传非为 0 的数值，因此，程序开始运行 echo "not exist" ，而 echo "not exist" 
程序肯定可以运行成功，因此会回传一个 0 值给后面的指令；</li>
<li>经过 &amp;&amp; 的判断，咦！是 0 啊！所以就开始运行 echo "exist" 。</li></ol>
所以啊，嘿嘿！第二个例子里面竟然会同时出现 not exist 与 exist 呢！真神奇～
</div>
</td></tr></tbody></table>
		<p>经过这个例题的练习，你应该会了解，<span class="text_import2">由于指令是一个接着一个去运行的，因此，如果真要使用判断，
		那么这个 &amp;&amp; 与 || 的顺序就不能搞错</span>。一般来说，假设判断式有三个，也就是：</p>
		<blockquote class="text_import2" style="font-family:&#39;细明体&#39;">
		command1 &amp;&amp; command2 || command3</blockquote>
		<p>而且顺序通常不会变，因为一般来说， command2 与 command3 会放置肯定可以运行成功的指令，
		因此，依据上面例题的逻辑分析，您就会晓得为何要如此放置啰～这很有用的啦！而且.....考试也很常考～</p>
	<br></div>
</div>
<a id="pipe"></a>
<div class="block1">
<h2>10.6 管线命令 (pipe)</h2>
	<p>就如同前面所说的， bash 命令运行的时候有输出的数据会出现！
	那么如果这群数据必需要经过几道手续之后才能得到我们所想要的格式，应该如何来设置？
	这就牵涉到管线命令的问题了 (pipe) ，<span class="text_import2">管线命令使用的是『 | 』这个界定符号</span>！
	另外，<span class="text_import2">管线命令与『连续下达命令』是不一样的呦</span>！
	这点底下我们会再说明。底下我们先举一个例子来说明一下简单的管线命令。</p>
	<p>假设我们想要知道 /etc/ 底下有多少文件，那么可以利用 ls /etc 来查阅，不过，
	因为 /etc 底下的文件太多，导致一口气就将屏幕塞满了～不知道前面输出的内容是啥？此时，我们可以透过 
	less 指令的协助，利用：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">ls -al /etc | less</span>
</pre></td></tr></tbody></table>
	<p>如此一来，使用 ls 指令输出后的内容，就能够被 less 读取，并且利用 less 
	的功能，我们就能够前后翻动相关的信息了！很方便是吧？我们就来了解一下这个管线命令『 | 』的用途吧！
	其实<span class="text_import2">这个管线命令『 | 』仅能处理经由前面一个指令传来的正确信息，也就是 standard output 
	的信息，对于 stdandard error 并没有直接处理的能力</span>。那么整体的管线命令可以使用下图表示：</p>
	<a id="fig10.6.1"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/0320bash_3.png" alt="线命令的处理示意图" title="线命令的处理示意图" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.6.1、管线命令的处理示意图</div>
	<p>在每个管线后面接的第一个数据必定是『指令』喔！而且<span class="text_import2">这个指令必须要能够接受 standard input
	的数据</span>才行，这样的指令才可以是为『管线命令』，例如 less, more, head, tail 等都是可以接受 standard input
	的管线命令啦。至于例如 ls, cp, mv 等就不是管线命令了！因为 ls, cp, mv 并不会接受来自 stdin 的数据。
	也就是说，管线命令主要有两个比较需要注意的地方：</p>
	<ul class="text_import2">
	<li>管线命令仅会处理 standard output，对于 standard error output 会予以忽略</li>
	<li>管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。</li>
	</ul>
	<fieldset class="vbirdface"><legend style="font-family: serif; font-size:12pt; color: darkblue;">Tips</legend><img src="./vbird_files/vbird_face.gif" alt="鸟哥的图标" title="鸟哥的图标" style="float: right;">	想一想，如果你硬要让 standard error 可以被管线命令所使用，那该如何处理？其实就是透过上一小节的数据流重导向即可！
	让 2&gt;&amp;1 加入指令中～就可以让 2&gt; 变成 1&gt; 啰！了解了吗？ ^_^
	</fieldset><br>
	<p>多说无益，让我们来玩一些管线命令吧！底下的咚咚对系统管理非常有帮助喔！</p>
	<a id="pipe_1"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.1 截取命令： cut, grep</h2>
		<p>什么是截取命令啊？说穿了，就是将一段数据经过分析后，取出我们所想要的。或者是经由分析关键字，取得我们所想要的那一行！
		不过，要注意的是，一般来说，<span class="text_import2">截取消息通常是针对『一行一行』来分析的</span>，
		并不是整篇消息分析的喔～底下我们介绍两个很常用的消息截取命令：</p>
		<a id="cut"></a>
		<ul class="toplist"><li>cut</li></ul>
		<p>cut 不就是『切』吗？没错啦！这个指令可以将一段消息的某一段给他『切』出来～
		处理的消息是以『行』为单位喔！底下我们就来谈一谈：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">cut -d'分隔字符' -f fields</span> <span class="term_note">&lt;==用于有特定分隔字符</span>
[dmtsai@study ~]$ <span class="term_command">cut -c 字符区间           </span> <span class="term_note">&lt;==用于排列整齐的消息</span>
<span class="term_say">选项与参数：
-d  ：后面接分隔字符。与 -f 一起使用；
-f  ：依据 -d 的分隔字符将一段消息分割成为数段，用 -f 取出第几段的意思；
-c  ：以字符 (characters) 的单位取出固定字符区间；</span>
<span class="term_hd"><a id="20070405"></a>范例一：将 PATH 变量取出，我要找出第五个路径。</span>
[dmtsai@study ~]$ <span class="term_command">echo ${PATH}</span>
/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin
<span class="term_say">#      1      |    2   |       3       |    4    |           5           |      6         |</span>
[dmtsai@study ~]$ <span class="term_command">echo ${PATH} | cut -d ':' -f 5</span>
<span class="term_say"># 如同上面的数字显示，我们是以『 : 』作为分隔，因此会出现 /home/dmtsai/.local/bin
# 那么如果想要列出第 3 与第 5 呢？，就是这样：</span>
[dmtsai@study ~]$ <span class="term_command">echo ${PATH} | cut -d ':' -f 3,5</span>
<span class="term_hd">范例二：将 export 输出的消息，取得第 12 字符以后的所有字符串</span>
[dmtsai@study ~]$ <span class="term_command">export</span>
declare -x HISTCONTROL="ignoredups"
declare -x HISTSIZE="1000"
declare -x HOME="/home/dmtsai"
declare -x HOSTNAME="study.centos.vbird"
<span class="term_say">.....(其他省略).....
# 注意看，每个数据都是排列整齐的输出！如果我们不想要『 declare -x 』时，就得这么做：</span>
[dmtsai@study ~]$ <span class="term_command">export | cut -c 12-</span>
HISTCONTROL="ignoredups"
HISTSIZE="1000"
HOME="/home/dmtsai"
HOSTNAME="study.centos.vbird"
<span class="term_say">.....(其他省略).....
# 知道怎么回事了吧？用 -c 可以处理比较具有格式的输出数据！
# 我们还可以指定某个范围的值，例如第 12-20 的字符，就是 cut -c 12-20 等等！</span>
<a id="last"></a>
<span class="term_hd">范例三：用 last 将显示的登录者的信息中，仅留下用户大名</span>
[dmtsai@study ~]$ <span class="term_command">last</span>
root   pts/1    192.168.201.101  Sat Feb  7 12:35   still logged in
root   pts/1    192.168.201.101  Fri Feb  6 12:13 - 18:46  (06:33)
root   pts/1    192.168.201.254  Thu Feb  5 22:37 - 23:53  (01:16)
<span class="term_say"># last 可以输出『帐号/终端机/来源/日期时间』的数据，并且是排列整齐的</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f 1</span>
<span class="term_say"># 由输出的结果我们可以发现第一个空白分隔的字段代表帐号，所以使用如上指令：
# 但是因为 root   pts/1 之间空格有好几个，并非仅有一个，所以，如果要找出 
# pts/1 其实不能以 cut -d ' ' -f 1,2 喔！输出的结果会不是我们想要的。</span>
</pre></td></tr></tbody></table>
		<p>cut 主要的用途在于将『同一行里面的数据进行分解！』最常使用在分析一些数据或文本数据的时候！
		这是因为有时候我们会以某些字符当作分割的参数，然后来将数据加以切割，以取得我们所需要的数据。
		鸟哥也很常使用这个功能呢！尤其是在分析 log 文件的时候！不过，cut 
		在处理多空格相连的数据时，可能会比较吃力一点，所以某些时刻可能会使用下一章的 awk 来取代的！</p>
		<a id="grep"></a>
		<ul class="toplist"><li>grep</li></ul>
		<p>刚刚的 cut 是将一行消息当中，取出某部分我们想要的，而 grep 则是分析一行消息，
		若当中有我们所需要的信息，就将该行拿出来～简单的语法是这样的：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">grep [-acinv] [--color=auto] '搜索字符串' filename</span>
<span class="term_say">选项与参数：
-a ：将 binary 文件以 text 文件的方式搜索数据
-c ：计算找到 '搜索字符串' 的次数
-i ：忽略大小写的不同，所以大小写视为相同
-n ：顺便输出行号
-v ：反向选择，亦即显示出没有 '搜索字符串' 内容的那一行！
--color=auto ：可以将找到的关键字部分加上颜色的显示喔！</span>
<span class="term_hd">范例一：将 last 当中，有出现 root 的那一行就取出来；</span>
[dmtsai@study ~]$ <span class="term_command">last | grep 'root'</span>
<span class="term_hd">范例二：与范例一相反，只要没有 root 的就取出！</span>
[dmtsai@study ~]$ <span class="term_command">last | grep -v 'root'</span>
<span class="term_hd">范例三：在 last 的输出消息中，只要有 root 就取出，并且仅取第一栏</span>
[dmtsai@study ~]$ <span class="term_command">last | grep 'root' |cut -d ' ' -f1</span>
<span class="term_say"># 在取出 root 之后，利用上个指令 cut 的处理，就能够仅取得第一栏啰！</span>
<span class="term_hd">范例四：取出 /etc/man_db.conf 内含 MANPATH 的那几行</span>
[dmtsai@study ~]$ <span class="term_command">grep --color=auto 'MANPATH' /etc/man_db.conf</span>
<span class="term_say">....(前面省略)....</span>
<span class="term_write">MANPATH</span>_MAP     /usr/games              /usr/share/man
<span class="term_write">MANPATH</span>_MAP     /opt/bin                /opt/man
<span class="term_write">MANPATH</span>_MAP     /opt/sbin               /opt/man
<span class="term_say"># 神奇的是，如果加上 --color=auto 的选项，找到的关键字部分会用特殊颜色显示喔！</span>
</pre></td></tr></tbody></table>
		<p>grep 是个很棒的指令喔！他支持的语法实在是太多了～用在正规表示法里头，
		能够处理的数据实在是多的很～不过，我们这里先不谈正规表示法～下一章再来说明～
		您先了解一下， grep 可以解析一行文本，取得关键字，若该行有存在关键字，就会整行列出来！另外， CentOS 7 当中，缺省的 
		grep 已经主动加上 --color=auto 在 alias 内了喔！</p>
	<br></div><br>
	<a id="pipe_2"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.2 排序命令： sort, wc, uniq</h2>
		<p>很多时候，我们都会去计算一次数据里头的相同型态的数据总数，举例来说，
		使用 last 可以查得系统上面有登录主机者的身份。那么我可以针对每个用户查出他们的总登录次数吗？
		此时就得要排序与计算之类的指令来辅助了！底下我们介绍几个好用的排序与统计指令喔！</p>
		<a id="sort"></a>
		<ul class="toplist"><li>sort</li></ul>
		<p>sort 是很有趣的指令，他可以帮我们进行排序，而且可以依据不同的数据型态来排序喔！
		例如数字与文本的排序就不一样。此外，排序的字符与语系的编码有关，因此，
		如果您需要排序时，建议使用 LANG=C 来让语系统一，数据排序比较好一些。</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">sort [-fbMnrtuk] [file or stdin]</span>
<span class="term_say">选项与参数：
-f  ：忽略大小写的差异，例如 A 与 a 视为编码相同；
-b  ：忽略最前面的空白字符部分；
-M  ：以月份的名字来排序，例如 JAN, DEC 等等的排序方法；
-n  ：使用『纯数字』进行排序(缺省是以文本型态来排序的)；
-r  ：反向排序；
-u  ：就是 uniq ，相同的数据中，仅出现一行代表；
-t  ：分隔符号，缺省是用 [tab] 键来分隔；
-k  ：以那个区间 (field) 来进行排序的意思</span>
<span class="term_hd">范例一：个人帐号都记录在 /etc/passwd 下，请将帐号进行排序。</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | sort</span>
<span class="term_write">ab</span>rt:x:173:173::/etc/abrt:/sbin/nologin
<span class="term_write">ad</span>m:x:3:4:adm:/var/adm:/sbin/nologin
<span class="term_write">al</span>ex:x:1001:1002::/home/alex:/bin/bash
<span class="term_say"># 鸟哥省略很多的输出～由上面的数据看起来， sort 是缺省『以第一个』数据来排序，
# 而且缺省是以『文本』型态来排序的喔！所以由 a 开始排到最后啰！</span>
<span class="term_hd">范例二：/etc/passwd 内容是以 : 来分隔的，我想以第三栏含后面数据来排序，该如何？</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | sort -t ':' -k 3</span>
root:x:<span class="term_write">0:0:root:/root:/bin/bash</span>
dmtsai:x:<span class="term_write">1000:1000:dmtsai:/home/dmtsai:/bin/bash</span>
alex:x:<span class="term_write">1001:1002::/home/alex:/bin/bash</span>
arod:x:<span class="term_write">1002:1003::/home/arod:/bin/bash</span>
<span class="term_say"># 看到特殊字体的输出部分了吧？怎么会这样排列啊？呵呵！没错啦～若单纯以第三字段来处理则是：</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | sort -t ':' -k 3,3</span>
# 如果是以文本型态来排序的话，原本就会是这样，想要使用数字排序：
# cat /etc/passwd | sort -t ':' -k 3,3 -n
# 这样才行啊！用那个 -n 来告知 sort 以数字来排序啊！
<span class="term_hd">范例三：利用 last ，将输出的数据仅取帐号，并加以排序</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort</span>
</pre></td></tr></tbody></table>
		<p>sort 同样是很常用的指令呢！因为我们常常需要比较一些信息啦！
		举个上面的第二个例子来说好了！今天假设你有很多的帐号，而且你想要知道最大的用户 
		ID 目前到哪一号了！呵呵！使用 sort 一下子就可以知道答案咯！当然其使用还不止此啦！有空的话不妨玩一玩！</p>
		<a id="uniq"></a>
		<ul class="toplist"><li>uniq</li></ul>
		<p>如果我排序完成了，想要将重复的数据仅列出一个显示，可以怎么做呢？</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">uniq [-ic]</span>
<span class="term_say">选项与参数：
-i  ：忽略大小写字符的不同；
-c  ：进行计数</span>
<span class="term_hd">范例一：使用 last 将帐号列出，仅取出帐号栏，进行排序后仅取出一位；</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort | uniq</span>
<span class="term_hd">范例二：承上题，如果我还想要知道每个人的登录总次数呢？</span>
[dmtsai@study ~]$ <span class="term_command">last | cut -d ' ' -f1 | sort | uniq -c</span>
      1
      6 (unknown
     47 dmtsai
      4 reboot
      7 root
      1 wtmp
<span class="term_say"># 从上面的结果可以发现 reboot 有 4 次， root 登录则有 7 次！大部分是以 dmtsai 来操作！
# wtmp 与第一行的空白都是 last 的缺省字符，那两个可以忽略的！</span>
</pre></td></tr></tbody></table>
		<p>这个指令用来将『重复的行删除掉只显示一个』，举个例子来说，
		你要知道这个月份登录你主机的用户有谁，而不在乎他的登录次数，那么就使用上面的范例，
		(1)先将所有的数据列出；(2)再将人名独立出来；(3)经过排序；(4)只显示一个！
		由于这个指令是在将重复的东西减少，所以当然需要『配合排序过的文件』来处理啰！</p>
		<a id="wc"></a>
		<ul class="toplist"><li>wc</li></ul>
		<p>如果我想要知道 /etc/man_db.conf 这个文件里面有多少字？多少行？多少字符的话，
		可以怎么做呢？其实可以利用 wc 这个指令来达成喔！他可以帮我们计算输出的消息的整体数据！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">wc [-lwm]</span>
<span class="term_say">选项与参数：
-l  ：仅列出行；
-w  ：仅列出多少字(英文单字)；
-m  ：多少字符；</span>
<span class="term_hd">范例一：那个 /etc/man_db.conf 里面到底有多少相关字、行、字符数？</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/man_db.conf | wc </span>
    131     723    5171
<span class="term_say"># 输出的三个数字中，分别代表： 『行、字数、字符数』</span>
<span class="term_hd">范例二：我知道使用 last 可以输出登录者，但是 last 最后两行并非帐号内容，那么请问，
        我该如何以一行指令串取得登录系统的总人次？</span>
[dmtsai@study ~]$ <span class="term_command">last | grep [a-zA-Z] | grep -v 'wtmp' | grep -v 'reboot' | \</span>
&gt; <span class="term_command">grep -v 'unknown' |wc -l </span>
<span class="term_say"># 由于 last 会输出空白行, wtmp, unknown, reboot 等无关帐号登录的信息，因此，我利用
# grep 取出非空白行，以及去除上述关键字那几行，再计算行数，就能够了解啰！</span>
</pre></td></tr></tbody></table>
		<p><a id="20100416"></a>wc 也可以当作指令？这可不是上洗手间的 WC 
		呢！这是相当有用的计算文件内容的一个工具组喔！举个例子来说，
		当你要知道目前你的帐号文件中有多少个帐号时，就使用这个方法：『
		cat /etc/passwd | wc -l 』啦！因为 /etc/passwd 里头一行代表一个用户呀！
		所以知道行数就晓得有多少的帐号在里头了！而如果要计算一个文件里头有多少个字符时，就使用
		wc -m 这个选项吧！</p>
	<br></div><br>
	<a id="pipe_3"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.3 双向重导向： tee</h2>
	<a id="tee"></a>
		<p>想个简单的东西，我们由前一节知道 &gt; 会将数据流整个发送给文件或设备，因此我们除非去读取该文件或设备，
		否则就无法继续利用这个数据流。万一我想要将这个数据流的处理过程中将某段消息存下来，应该怎么做？
		利用 tee 就可以啰～我们可以这样简单的看一下：</p>
	<a id="fig10.6.2"></a>
	<div style="text-align:center; margin: 0 auto 0 auto; "><img src="./vbird_files/0320bash_5.png" alt="tee 的工作流程示意图" title="tee 的工作流程示意图" style="border: 1px solid black; padding: 10px "></div>
	<div style="text-align: center;">图10.6.2、tee 的工作流程示意图</div>
		<p>tee 会同时将数据流分送到文件去与屏幕 (screen)；而输出到屏幕的，其实就是 stdout ，那就可以让下个指令继续处理喔！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">tee [-a] file</span>
<span class="term_say">选项与参数：
-a  ：以累加 (append) 的方式，将数据加入 file 当中！</span>
[dmtsai@study ~]$ <span class="term_command">last | tee last.list | cut -d " " -f1</span>
<span class="term_say"># 这个范例可以让我们将 last 的输出存一份到 last.list 文件中；</span>
[dmtsai@study ~]$ <span class="term_command">ls -l /home | tee ~/homefile | more</span>
<span class="term_say"># 这个范例则是将 ls 的数据存一份到 ~/homefile ，同时屏幕也有输出消息！</span>
[dmtsai@study ~]$ <span class="term_command">ls -l / | tee -a ~/homefile | more</span>
<span class="term_say"># 要注意！ tee 后接的文件会被覆盖，若加上 -a 这个选项则能将消息累加。</span>
</pre></td></tr></tbody></table>
		<p>tee 可以让 standard output 转存一份到文件内并将同样的数据继续送到屏幕去处理！
		这样除了可以让我们同时分析一份数据并记录下来之外，还可以作为处理一份数据的中间暂存盘记录之用！
		tee 这家伙在很多选择/填充的认证考试中很容易考呢！</p>
	<br></div><br>
	<a id="pipe_4"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.4 字符转换命令： tr, col, join, paste, expand</h2>
		<p>我们在 <a href="0310vi.html#tips_dos">vim 程序编辑器</a>当中，提到过 DOS 
		断行字符与 Unix 断行字符的不同，并且可以使用 dos2unix 与 unix2dos 
		来完成转换。好了，那么思考一下，是否还有其他常用的字符替代？
		举例来说，要将大写改成小写，或者是将数据中的 [tab] 按键转成空白键？还有，如何将两篇消息集成成一篇？
		底下我们就来介绍一下这些字符转换命令在管线当中的使用方法：</p>
		<a id="tr"></a>
		<ul class="toplist"><li>tr</li></ul>
		<p>tr 可以用来删除一段消息当中的文本，或者是进行文本消息的替换！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">tr [-ds] SET1 ...</span>
<span class="term_say">选项与参数：
-d  ：删除消息当中的 SET1 这个字符串；
-s  ：取代掉重复的字符！</span>
<span class="term_hd">范例一：将 last 输出的消息中，所有的小写变成大写字符：</span>
[dmtsai@study ~]$ <span class="term_command">last | tr '[a-z]' '[A-Z]'</span>
<span class="term_say"># 事实上，没有加上单引号也是可以运行的，如：『 last | tr [a-z] [A-Z] 』</span>
<span class="term_hd">范例二：将 /etc/passwd 输出的消息中，将冒号 (:) 删除</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/passwd | tr -d ':'</span>
<span class="term_hd">范例三：将 /etc/passwd 转存成 dos 断行到 /root/passwd 中，再将 ^M 符号删除</span>
[dmtsai@study ~]$ <span class="term_command">cp /etc/passwd ~/passwd &amp;&amp; unix2dos ~/passwd</span>
[dmtsai@study ~]$ <span class="term_command">file /etc/passwd ~/passwd</span>
/etc/passwd:         ASCII text
/home/dmtsai/passwd: ASCII text, with CRLF line terminators  <span class="term_note">&lt;==就是 DOS 断行</span>
[dmtsai@study ~]$ <span class="term_command">cat ~/passwd | tr -d '\r' &gt; ~/passwd.linux</span>
<span class="term_say"># 那个 \r 指的是 DOS 的断行字符，关于更多的字符，请参考 man tr</span>
[dmtsai@study ~]$ <span class="term_command">ll /etc/passwd ~/passwd*</span>
-rw-r--r--. 1 root   root   <span class="term_write">2092</span> Jun 17 00:20 /etc/passwd
-rw-r--r--. 1 dmtsai dmtsai <span class="term_write">2133</span> Jul  9 22:13 /home/dmtsai/passwd
-rw-rw-r--. 1 dmtsai dmtsai <span class="term_write">2092</span> Jul  9 22:13 /home/dmtsai/passwd.linux
<span class="term_say"># 处理过后，发现文件大小与原本的 /etc/passwd 就一致了！</span>
</pre></td></tr></tbody></table>
		<p>其实这个指令也可以写在『正规表示法』里头！因为他也是由正规表示法的方式来取代数据的！
		以上面的例子来说，使用 [] 可以设置一串字呢！<span class="text_import2">也常常用来取代文件中的怪异符号</span>！
		例如上面第三个例子当中，可以去除 DOS 文件留下来的 ^M 这个断行的符号！这东西相当的有用！相信处理 Linux &amp;
		Windows 系统中的人们最麻烦的一件事就是这个事情啦！亦即是 DOS 底下会自动的在每行行尾加入
		^M 这个断行符号！这个时候除了以前讲过的 dos2unix 之外，我们也可以使用这个 tr 来将 ^M 去除！ ^M 可以使用
		\r 来代替之！</p>
		<a id="col"></a>
		<ul class="toplist"><li>col</li></ul>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">col [-xb]</span>
<span class="term_say">选项与参数：
-x  ：将 tab 键转换成对等的空白键</span>
<span class="term_hd">范例一：利用 cat -A 显示出所有特殊按键，最后以 col 将 [tab] 转成空白</span>
[dmtsai@study ~]$ <span class="term_command">cat -A /etc/man_db.conf</span>  <span class="term_note">&lt;==此时会看到很多 ^I 的符号，那就是 tab</span>
[dmtsai@study ~]$ <span class="term_command">cat /etc/man_db.conf | col -x | cat -A | more</span>
<span class="term_say"># 嘿嘿！如此一来， [tab] 按键会被取代成为空白键，输出就美观多了！</span>
</pre></td></tr></tbody></table>
		<p>虽然 col 有他特殊的用途，不过，很多时候，他可以用来简单的处理将 [tab] 按键取代成为空白键！
		例如上面的例子当中，如果使用 cat -A 则 [tab] 会以 ^I 来表示。
		但经过 col -x 的处理，则会将 [tab] 取代成为对等的空白键！</p>
		<a id="join"></a>
		<ul class="toplist"><li>join</li></ul>
		<p>join 看字面上的意义 (加入/参加) 就可以知道，他是在处理两个文件之间的数据，
		而且，主要是在处理『<span class="text_import2">两个文件当中，有 <strong>"相同数据"</strong> 
		的那一行，才将他加在一起</span>』的意思。我们利用底下的简单例子来说明：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">join [-ti12] file1 file2</span>
<span class="term_say">选项与参数：
-t  ：join 缺省以空白字符分隔数据，并且比对『第一个字段』的数据，
      如果两个文件相同，则将两笔数据联成一行，且第一个字段放在第一个！
-i  ：忽略大小写的差异；
-1  ：这个是数字的 1 ，代表『第一个文件要用那个字段来分析』的意思；
-2  ：代表『第二个文件要用那个字段来分析』的意思。</span>
<span class="term_hd">范例一：用 root 的身份，将 /etc/passwd 与 /etc/shadow 相关数据集成成一栏</span>
[root@study ~]# <span class="term_command">head -n 3 /etc/passwd /etc/shadow</span>
==&gt; /etc/passwd &lt;==
root:x:0:0:root:/root:/bin/bash
bin:x:1:1:bin:/bin:/sbin/nologin
daemon:x:2:2:daemon:/sbin:/sbin/nologin
==&gt; /etc/shadow &lt;==
root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:*:16372:0:99999:7:::
daemon:*:16372:0:99999:7:::
<span class="term_say"># 由输出的数据可以发现这两个文件的最左边字段都是相同帐号！且以 : 分隔</span>
[root@study ~]# <span class="term_command">join -t ':' /etc/passwd /etc/shadow | head -n 3</span>
<span class="term_write">root</span>:x:0:0:root:/root:/bin/bash:<span class="term_write">$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::</span>
<span class="term_write">bin</span>:x:1:1:bin:/bin:/sbin/nologin:<span class="term_write">*:16372:0:99999:7:::</span>
<span class="term_write">daemon</span>:x:2:2:daemon:/sbin:/sbin/nologin:<span class="term_write">*:16372:0:99999:7:::</span>
<span class="term_say"># 透过上面这个动作，我们可以将两个文件第一字段相同者集成成一列！
# 第二个文件的相同字段并不会显示(因为已经在最左边的字段出现了啊！)</span>
<span class="term_hd">范例二：我们知道 /etc/passwd 第四个字段是 GID ，那个 GID 记录在 
        /etc/group 当中的第三个字段，请问如何将两个文件集成？</span>
[root@study ~]# <span class="term_command">head -n 3 /etc/passwd /etc/group</span>
==&gt; /etc/passwd &lt;==
root:x:0:<span class="term_write">0</span>:root:/root:/bin/bash
bin:x:1:<span class="term_write">1</span>:bin:/bin:/sbin/nologin
daemon:x:2:<span class="term_write">2</span>:daemon:/sbin:/sbin/nologin
==&gt; /etc/group &lt;==
root:x:<span class="term_write">0</span>:
bin:x:<span class="term_write">1</span>:
daemon:x:<span class="term_write">2</span>:
<span class="term_say"># 从上面可以看到，确实有相同的部分喔！赶紧来集成一下！</span>
[root@study ~]# <span class="term_command">join -t ':' -1 4 /etc/passwd -2 3 /etc/group | head -n 3</span>
<span class="term_write">0</span>:root:x:0:root:/root:/bin/bash:<span class="term_write">root:x:</span>
<span class="term_write">1</span>:bin:x:1:bin:/bin:/sbin/nologin:<span class="term_write">bin:x:</span>
<span class="term_write">2</span>:daemon:x:2:daemon:/sbin:/sbin/nologin:<span class="term_write">daemon:x:</span>
<span class="term_say"># 同样的，相同的字段部分被移动到最前面了！所以第二个文件的内容就没再显示。
# 请读者们配合上述显示两个文件的实际内容来比对！</span>
</pre></td></tr></tbody></table>
		<p>这个 join 在处理两个相关的数据文件时，就真的是很有帮助的啦！
		例如上面的案例当中，我的 /etc/passwd, /etc/shadow, /etc/group 都是有相关性的，
		其中 /etc/passwd, /etc/shadow 以帐号为相关性，至于 /etc/passwd, /etc/group 
		则以所谓的 GID (帐号的数字定义) 来作为他的相关性。根据这个相关性，
		我们可以将有关系的数据放置在一起！这在处理数据可是相当有帮助的！
		但是上面的例子有点难，希望您可以静下心好好的看一看原因喔！</p>
		<p><a id="20070411"></a>此外，需要特别注意的是，<span class="text_import2">在使用 join 
		之前，你所需要处理的文件应该要事先经过排序 (sort) 处理</span>！
		否则有些比对的项目会被略过呢！特别注意了！</p>
		<a id="paste"></a>
		<ul class="toplist"><li>paste</li></ul>
		<p>这个 paste 就要比 join 简单多了！相对于 join 必须要比对两个文件的数据相关性，
		paste 就直接『<span class="text_import2">将两行贴在一起，且中间以 [tab] 键隔开</span>』而已！简单的使用方法：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">paste [-d] file1 file2</span>
<span class="term_say">选项与参数：
-d  ：后面可以接分隔字符。缺省是以 [tab] 来分隔的！
-   ：如果 file 部分写成 - ，表示来自 standard input 的数据的意思。</span>
<span class="term_hd">范例一：用 root 身份，将 /etc/passwd 与 /etc/shadow 同一行贴在一起</span>
[root@study ~]# <span class="term_command">paste /etc/passwd /etc/shadow</span>
root:x:0:0:root:/root:/bin/bash root:$6$wtbCCce/PxMeE5wm$KE2IfSJr...:16559:0:99999:7:::
bin:x:1:1:bin:/bin:/sbin/nologin        bin:*:16372:0:99999:7:::
daemon:x:2:2:daemon:/sbin:/sbin/nologin daemon:*:16372:0:99999:7:::
<span class="term_say"># 注意喔！同一行中间是以 [tab] 按键隔开的！</span>
<span class="term_hd">范例二：先将 /etc/group 读出(用 cat)，然后与范例一粘贴一起！且仅取出前三行</span>
[root@study ~]# <span class="term_command">cat /etc/group|paste /etc/passwd /etc/shadow -|head -n 3</span>
<span class="term_say"># 这个例子的重点在那个 - 的使用！那玩意儿常常代表 stdin 喔！</span>
</pre></td></tr></tbody></table>
		<a id="expand"></a>
		<ul class="toplist"><li>expand</li></ul>
		<p>这玩意儿就是在将 [tab] 按键转成空白键啦～可以这样玩：</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">expand [-t] file</span>
<span class="term_say">选项与参数：
-t  ：后面可以接数字。一般来说，一个 tab 按键可以用 8 个空白键取代。
      我们也可以自行定义一个 [tab] 按键代表多少个字符呢！</span>
<span class="term_hd">范例一：将 /etc/man_db.conf 内行首为 MANPATH 的字样就取出；仅取前三行；</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3</span>
MANPATH_MAP     /bin                    /usr/share/man
MANPATH_MAP     /usr/bin                /usr/share/man
MANPATH_MAP     /sbin                   /usr/share/man
<span class="term_say"># 行首的代表标志为 ^ ，这个我们留待下节介绍！先有概念即可！</span>
<span class="term_hd">范例二：承上，如果我想要将所有的符号都列出来？(用 cat)</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3 |cat -A</span>
MANPATH_MAP^I/bin^I^I^I/usr/share/man$
MANPATH_MAP^I/usr/bin^I^I/usr/share/man$
MANPATH_MAP^I/sbin^I^I^I/usr/share/man$
<span class="term_say"># 发现差别了吗？没错～ [tab] 按键可以被 cat -A 显示成为 ^I </span>
<span class="term_hd">范例三：承上，我将 [tab] 按键设置成 6 个字符的话？</span>
[dmtsai@study ~]$ <span class="term_command">grep '^MANPATH' /etc/man_db.conf | head -n 3 | expand -t 6 - | cat -A</span>
MANPATH_MAP /bin              /usr/share/man$
MANPATH_MAP /usr/bin          /usr/share/man$
MANPATH_MAP /sbin             /usr/share/man$
<span class="term_say">123456123456123456123456123456123456123456123456...
# 仔细看一下上面的数字说明，因为我是以 6 个字符来代表一个 [tab] 的长度，所以，
# MAN... 到 /usr 之间会隔 12 (两个 [tab]) 个字符喔！如果 tab 改成 9 的话，
# 情况就又不同了！这里也不好理解～您可以多设置几个数字来查阅就晓得！</span>
</pre></td></tr></tbody></table>
		<p>expand 也是挺好玩的～他会自动将 [tab] 转成空白键～所以，以上面的例子来说，
		使用 cat -A 就会查不到 ^I 的字符啰～此外，因为 [tab] 最大的功能就是格式排列整齐！
		我们转成空白键后，这个空白键也会依据我们自己的定义来增加大小～
		所以，并不是一个 ^I 就会换成 8 个空白喔！这个地方要特别注意的哩！
		此外，您也可以参考一下 unexpand 这个将空白转成 [tab] 的指令功能啊！ ^_^</p>
	<br></div><br>
	<a id="split"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.5 分割命令： split</h2>
		<p>如果你有文件太大，导致一些携带式设备无法复制的问题，嘿嘿！找 split 就对了！
		他可以帮你将一个大文件，依据文件大小或行数来分割，就可以将大文件分割成为小文件了！
		快速又有效啊！真不错～</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">split [-bl] file PREFIX</span>
<span class="term_say">选项与参数：
-b  ：后面可接欲分割成的文件大小，可加单位，例如 b, k, m 等；
-l  ：以行数来进行分割。
PREFIX ：代表前置字符的意思，可作为分割文件的前导文本。</span>
<span class="term_hd">范例一：我的 /etc/services 有六百多K，若想要分成 300K 一个文件时？</span>
[dmtsai@study ~]$ <span class="term_command">cd /tmp; split -b 300k /etc/services services</span>
[dmtsai@study tmp]$ <span class="term_command">ll -k services*</span>
-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 services<span class="term_write">aa</span>
-rw-rw-r--. 1 dmtsai dmtsai 307200 Jul  9 22:52 services<span class="term_write">ab</span>
-rw-rw-r--. 1 dmtsai dmtsai  55893 Jul  9 22:52 services<span class="term_write">ac</span>
<span class="term_say"># 那个文件名可以随意取的啦！我们只要写上前导文本，小文件就会以
# xxxaa, xxxab, xxxac 等方式来创建小文件的！</span>
<span class="term_hd">范例二：如何将上面的三个小文件合成一个文件，文件名为 servicesback</span>
[dmtsai@study tmp]$ <span class="term_command">cat services* &gt;&gt; servicesback</span>
<span class="term_say"># 很简单吧？就用数据流重导向就好啦！简单！</span>
<span class="term_hd">范例三：使用 ls -al / 输出的信息中，每十行记录成一个文件</span>
[dmtsai@study tmp]$ <span class="term_command">ls -al / | split -l 10 - lsroot</span>
[dmtsai@study tmp]$ <span class="term_command">wc -l lsroot*</span>
  10 lsrootaa
  10 lsrootab
   4 lsrootac
  24 total
<span class="term_say"># 重点在那个 - 啦！一般来说，如果需要 stdout/stdin 时，但偏偏又没有文件，
# 有的只是 - 时，那么那个 - 就会被当成 stdin 或 stdout ～</span>
</pre></td></tr></tbody></table>
		<p>在 Windows 操作系统下，你要将文件分割需要如何作？伤脑筋吧！在 Linux 
		底下就简单的多了！你要将文件分割的话，那么就使用 -b size 
		来将一个分割的文件限制其大小，如果是行数的话，那么就使用
		-l line 来分割！好用的很！如此一来，你就可以轻易的将你的文件分割成某些软件能够支持的最大容量 (例如 gmail 单一信件 25MB 之类的！)，方便你 copy 啰！</p>
	<br></div><br>
	<a id="xargs"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.6 参数代换： xargs</h2>
		<p>xargs 是在做什么的呢？就以字面上的意义来看， x 是加减乘除的乘号，args 则是 arguments (参数)
		的意思，所以说，<span class="text_import2">这个玩意儿就是在产生某个指令的参数的意思！</span>
		xargs 可以读入 stdin 的数据，并且以空白字符或断行字符作为分辨，将 stdin 的数据分隔成为 arguments 。
		因为是以空白字符作为分隔，所以，如果有一些文件名或者是其他意义的名词内含有空白字符的时候，
		xargs 可能就会误判了～他的用法其实也还满简单的！就来看一看先！</p>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">xargs [-0epn] command</span>
<span class="term_say">选项与参数：
-0  ：如果输入的 stdin 含有特殊字符，例如 `, \, 空白键等等字符时，这个 -0 参数
      可以将他还原成一般字符。这个参数可以用于特殊状态喔！
-e  ：这个是 EOF (end of file) 的意思。后面可以接一个字符串，当 xargs 分析到这个字符串时，
      就会停止继续工作！
-p  ：在运行每个指令的 argument 时，都会询问用户的意思；
-n  ：后面接次数，每次 command 指令运行时，要使用几个参数的意思。
当 xargs 后面没有接任何的指令时，缺省是以 echo 来进行输出喔！</span>
<span class="term_hd">范例一：将 /etc/passwd 内的第一栏取出，仅取三行，使用 id 这个指令将每个帐号内容秀出来</span>
[dmtsai@study ~]$ <span class="term_command">id root</span>
uid=0(root) gid=0(root) groups=0(root)   <span class="term_note"># 这个 id 指令可以查找用户的 UID/GID 等信息</span>
[dmtsai@study ~]$ <span class="term_command">id $(cut -d ':' -f 1 /etc/passwd | head -n 3)</span>
<span class="term_say"># 虽然使用 $(cmd) 可以预先取得参数，但可惜的是， id 这个指令『仅』能接受一个参数而已！
# 所以上述的这个指令运行会出现错误！根本不会显示用户的 ID 啊！</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | id</span>
uid=1000(dmtsai) gid=1000(dmtsai) groups=1000(dmtsai),10(wheel)   <span class="term_note"># 我不是要查自己啊！</span>
<span class="term_say"># 因为 id 并不是管线命令，因此在上面这个指令运行后，前面的东西通通不见！只会运行 id！</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs id</span>
<span class="term_say"># 依旧会出现错误！这是因为 xargs 一口气将全部的数据通通丢给 id 处理～但 id 就接受 1 个啊最多！</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -n 1 id</span>
uid=0(root) gid=0(root) groups=0(root)
uid=1(bin) gid=1(bin) groups=1(bin)
uid=2(daemon) gid=2(daemon) groups=2(daemon)
<span class="term_say"># 透过 -n 来处理，一次给予一个参数，因此上述的结果就 OK 正常的显示啰！</span>
<span class="term_hd">范例二：同上，但是每次运行 id 时，都要询问用户是否动作？</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | head -n 3 | xargs -p -n 1 id</span>
id root ?...<span class="term_command">y</span>
uid=0(root) gid=0(root) groups=0(root)
id bin ?...<span class="term_command">y</span>
<span class="term_say">.....(底下省略).....
# 呵呵！这个 -p 的选项可以让用户的使用过程中，被询问到每个指令是否运行！</span>
<span class="term_hd">范例三：将所有的 /etc/passwd 内的帐号都以 id 查阅，但查到 sync 就结束指令串</span>
[dmtsai@study ~]$ <span class="term_command">cut -d ':' -f 1 /etc/passwd | xargs -e'sync' -n 1 id</span>
<span class="term_say"># 仔细与上面的案例做比较。也同时注意，那个 -e'sync' 是连在一起的，中间没有空白键。
# 上个例子当中，第六个参数是 sync 啊，那么我们下达 -e'sync' 后，则分析到 sync 这个字符串时，
# 后面的其他 stdin 的内容就会被 xargs 舍弃掉了！</span>
</pre></td></tr></tbody></table>
		<p>其实，在 man xargs 里面就有三四个小范例，您可以自行参考一下内容。
		此外， xargs 真的是很好用的一个玩意儿！您真的需要好好的参详参详！会使用 xargs 的原因是，
		<span class="text_import2">很多指令其实并不支持管线命令，因此我们可以透过 xargs 来提供该指令引用 standard 
		input 之用</span>！举例来说，我们使用如下的范例来说明：</p>
<table class="term"><tbody><tr><td class="term"><pre><span class="term_hd">范例四：找出 /usr/sbin 底下具有特殊权限的文件名，并使用 ls -l 列出详细属性</span>
[dmtsai@study ~]$ <span class="term_command">find /usr/sbin -perm /7000 | xargs ls -l</span>
-rwx--s--x. 1 root lock      11208 Jun 10  2014 /usr/sbin/lockdev
-rwsr-xr-x. 1 root root     113400 Mar  6 12:17 /usr/sbin/mount.nfs
-rwxr-sr-x. 1 root root      11208 Mar  6 11:05 /usr/sbin/netreport
<span class="term_say">.....(底下省略).....
# 聪明的读者应该会想到使用『 ls -l $(find /usr/sbin -perm /7000) 』来处理这个范例！
# 都 OK！能解决问题的方法，就是好方法！</span>
</pre></td></tr></tbody></table>
	<br></div><br>
	<a id="pipe_7"></a>
	<div class="block2"><div class="gototop"><a href="0320bash.html#top">Top</a></div>
	<h2>10.6.7 关于减号 - 的用途</h2>
		<p>管线命令在 bash 的连续的处理进程中是相当重要的！另外，在 log file 的分析当中也是相当重要的一环，
		所以请特别留意！另外，在管线命令当中，常常会使用到前一个指令的 stdout 作为这次的 stdin ，
		某些指令需要用到文件名称 (例如 tar) 来进行处理时，该 stdin 与 stdout 可以利用减号 "-" 来替代，
		举例来说：</p>
<table class="term"><tbody><tr><td class="term"><pre>[root@study ~]# <span class="term_command">mkdir /tmp/homeback</span>
[root@study ~]# <span class="term_command">tar -cvf - /home | tar -xvf - -C /tmp/homeback</span>
</pre></td></tr></tbody></table>
		<p>上面这个例子是说：『我将 /home 里面的文件给他打包，但打包的数据不是纪录到文件，而是发送到 stdout；
		经过管线后，将 tar -cvf - /home 发送给后面的 tar -xvf - 』。后面的这个 - 则是取用前一个指令的 stdout，
		因此，我们就不需要使用 filename 了！这是很常见的例子喔！注意注意！</p>
	<br></div>
</div>
<a id="hint"></a>
<div class="block1">
<h2>10.7 重点回顾</h2>
<ul class="text_import2">
	<li>由于核心在内存中是受保护的区块，因此我们必须要透过『 Shell 』将我们输入的指令与 Kernel 沟通，好让 
		Kernel 可以控制硬件来正确无误的工作</li>
	<li>学习 shell 的原因主要有：文本接口的 shell 在各大 distribution 都一样；远程管理时文本接口速度较快；
		shell 是管理 Linux 系统非常重要的一环，因为 Linux 内很多控制都是以 shell 撰写的。</li>
	<li>系统合法的 shell 均写在 /etc/shells 文件中；</li>
	<li>用户缺省登录取得的 shell 记录于 /etc/passwd 的最后一个字段；</li>
	<li>bash 的功能主要有：命令编修能力；命令与文件补全功能；命令别名设置功能；工作控制、前景背景控制；程序化脚本；通配符</li>
	<li>type 可以用来找到运行指令为何种类型，亦可用于与 which 相同的功能；</li>
	<li>变量就是以一组文本或符号等，来取代一些设置或者是一串保留的数据</li>
	<li>变量主要有环境变量与自订变量，或称为全域变量与区域变量</li>
	<li>使用 env 与 export 可观察环境变量，其中 export 可以将自订变量转成环境变量；</li>
	<li>set 可以观察目前 bash 环境下的所有变量；</li>
	<li>$? 亦为变量，是前一个指令运行完毕后的回传值。在 Linux 回传值为 0 代表运行成功；</li>
	<li>locale 可用于观察语系数据；</li>
	<li>可用 read 让用户由键盘输入变量的值</li>
	<li>ulimit 可用以限制用户使用系统的资源情况</li>
	<li>bash 的设置档主要分为 login shell 与 non-login shell。login shell 主要读取 /etc/profile 与 ~/.bash_profile，
		non-login shell 则仅读取 ~/.bashrc</li>
	<li>在使用 vim 时，若不小心按了 [ctrl]+s 则画面会被冻结。你可以使用 [ctrl]+q 来解除冻结</li>
	<li>通配符主要有： *, ?, [] 等等</li>
	<li>数据流重导向透过 &gt;, 2&gt;, &lt; 之类的符号将输出的信息转到其他文件或设备去；</li>
	<li>连续命令的下达可透过 ; &amp;&amp; || 等符号来处理</li>
	<li>管线命令的重点是：『管线命令仅会处理 standard output，对于 standard error output 会予以忽略』
		『管线命令必须要能够接受来自前一个指令的数据成为 standard input 继续处理才行。』</li>
	<li>本章介绍的管线命令主要有：cut, grep, sort, wc, uniq, tee, tr, col, join, paste, expand, split, xargs 等。</li>
</ul>
</div>
<a id="ex"></a>
<div class="block1">
<h2>10.8 本章习题</h2>
( 要看答案请将鼠标移动到『答：』底下的空白处，按下左键圈选空白处即可察看 )
<ul>
	<li>情境仿真题一：由于 ~/.bash_history 仅能记录指令，我想要在每次注销时都记录时间，并将后续的指令 50 笔记录下来，
	可以如何处理？<br><br>
	<ul>
	<li>目标：了解 history ，并透过数据流重导向的方式记录历史命令；</li>
	<li>前提：需要了解本章的数据流重导向，以及了解 bash 的各个环境设置档信息。</li>
	</ul><br>
	其实处理的方式非常简单，我们可以了解 date 可以输出时间，而利用 ~/.myhistory 来记录所有历史记录，
	而目前最新的 50 笔历史记录可以使用 history 50 来显示，故可以修改 ~/.bash_logout 成为底下的模样：<br>
<table class="term"><tbody><tr><td class="term"><pre>[dmtsai@study ~]$ <span class="term_command">vim ~/.bash_logout</span>
<span class="term_write">date &gt;&gt; ~/.myhistory
history 50 &gt;&gt; ~/.myhistory</span>
clear
</pre></td></tr></tbody></table><br></li>
</ul>
<hr>简答题部分：
<ul>
	<li>在 Linux 上可以找到哪些 shell(举出三个) ？那个文件记录可用的 shell ？而 Linux 缺省的 shell 是？
	<div class="blockex">
		1) /bin/bash, /bin/tcsh, /bin/csh<br>
	 	2) /etc/shells<br>
		3) bash ，亦即是 /bin/bash。
	</div></li>
	<li>你输入一串指令之后，发现前面写的一长串数据是错的，你想要删除光标所在处到最前面的指令串内容，应该如何处理？
	<div class="blockex">
		按下 [ctrl]+u 组合键即可！
	</div></li>
	<li>在 shell 环境下，有个提示字符  (prompt)，他可以修改吗？要改什么？缺省的提示字符内容是？
	<div class="blockex">
		可以修改的，改 PS1 这个变量，这个 PS1 变量的缺省内容为：『[\u@\h \W]\$』
	</div></li>
	<li>如何显示 HOME 这个环境变量？
	<div class="blockex">
		echo $HOME
	</div></li>
	<li>如何得知目前的所有变量与环境变量的设置值？
	<div class="blockex">
		环境变量用 env 或 export 而所有变量用 set 即可显示
	</div></li>
	<li>我是否可以设置一个变量名称为 3myhome ？
	<div class="blockex">
		不行！变量不能以数字做为开头，参考变量设置规则的内容
	</div></li>
	<li>在这样的练习中『A=B』且『B=C』，若我下达『unset $A』，则取消的变量是 A 还是 B？
	<div class="blockex">
		被取消的是 B 喔，因为 unset $A 相当于 unset B 所以取消的是 B ，A 会继续存在！
	</div></li>
	<li>如何取消变量与命令别名的内容？
	<div class="blockex">
		使用 unset 及 unalias 即可
	</div></li>
	<li>如何设置一个变量名称为 name 内容为 It's my name ？
	<div class="blockex">
		name=It\'s\ my\ name 或 name="It's my name"
	</div></li>
	<li>bash 环境设置档主要分为哪两种类型的读取？分别读取哪些重要文件？
	<div class="blockex">
		(1)login shell：主要读取 /etc/profile 及 ~/.bash_profile<br>
		(2)non-logni shell：主要读取 ~/.bashrc 而已。
	</div></li>
	<li>CentOS 7.x 的 man page 的路径设置文件？
	<div class="blockex">
		/etc/man_db.conf
	</div></li>
	<li>试说明 ', ", 与 ` 这些符号在变量定义中的用途？
	<div class="blockex">
		参考变量规则那一章节，其中， " 可以具有变量的内容属性，' 则仅有一般字符，至于 ` 之内则是可先被运行的指令。
	</div></li>
	<li>跳脱符号 \ 有什么用途？
	<div class="blockex">
		可以用来跳脱特殊字符，例如 Enter, $ 等等，使成为一般字符！
	</div></li>
	<li>连续命令中， ;, &amp;&amp;, || 有何不同？
	<div class="blockex">
		分号可以让两个 command 连续运作，不考虑 command1
		的输出状态， &amp;&amp; 则前一个指令必需要没有错误消息，亦即回传值需为
		0 则 command2 才会被运行， || 则与 &amp;&amp; 相反！
	</div></li>
	<li>如何将 last 的结果中，独立出帐号，并且印出曾经登录过的帐号？
	<div class="blockex">
		&nbsp;last | cut -d ' ' -f1 | sort | uniq
	</div></li>
	<li>请问 foo1 &amp;&amp; foo2 | foo3 &gt; foo4 ，这个指令串当中， foo1/foo2/foo3/foo4 是指令还是文件？
	整串指令的意义为？
	<div class="blockex">
		foo1, foo2 与 foo3 都是指令， foo4 是设备或文件。整串指令意义为：<br>
		(1)当 foo1 运行结果有错误时，则该指令串结束；<br>
		(2)若 foo1 运行结果没有错误时，则运行 foo2 | foo3 &gt; foo4 ；其中：<br>
			(2-1)foo2 将 stdout 输出的结果传给 foo3 处理；<br>
			(2-2)foo3 将来自 foo2 的 stdout 当成 stdin ，处理完后将数据流重新导向 foo4 这个设备/文件
	</div></li>
	<li>如何秀出在 /bin 底下任何以 a 为开头的文件文件名的详细数据？
	<div class="blockex">
		ls -ld /bin/a*
	</div></li>
	<li>如何秀出 /bin 底下，文件名为四个字符的文件？
	<div class="blockex">
		ls -ld /bin/????
	</div></li>
	<li>如何秀出 /bin 底下，文件名开头不是 a-d 的文件？
	<div class="blockex">
		ls -ld /bin/[^a-d]*
	</div></li>
	<li>我想要让终端机接口的登录提示字符修改成我自己喜好的模样，应该要改哪里？(filename)
	<div class="blockex">
		/etc/issue
	</div></li>
	<li>承上题，如果我是想要让用户登录后，才显示欢迎消息，又应该要改哪里？
	<div class="blockex">
		/etc/motd
	</div></li>
</ul>
</div>
<a id="reference"></a>
<div class="block1">
<h2>10.9 参考数据与延伸阅读</h2>
<ul>
	<li><a id="ps1"></a>注1：Webmin 的官方网站：<a href="http://www.webmin.com/" target="_blank">http://www.webmin.com/</a></li>
	<li><a id="ps2"></a>注2：关于 shell 的相关历史可以参考网络农夫兄所整理的优秀文章。不过由于网络农夫兄所建置的网站暂时关闭，
		因此底下的链接为鸟哥到网络上找到的片段文章链接。若有任何侵权事宜，请来信告知，谢谢：
		<a href="0320bash/csh/" target="_blank">0320bash/csh/</a></li>
	<li><a id="ps3"></a>注3：使用 man bash，再以 PS1 为关键字去查找，按下数次 n 往后查找后，可以得到 PS1 的变量说明。</li>
	<li>在语系数据方面，i18n 是由一些 Linux distribution 贡献者共同发起的大型计划，目的在于让众多的 Linux
		distributions 能够有良好的万国码 (Unicode) 语系的支持。详细的数据可以参考：
		<ul>
		<li>i18n 的 wiki 介绍：<a href="https://en.wikipedia.org/wiki/Internationalization_and_localization" target="_blank">https://en.wikipedia.org/wiki/Internationalization_and_localization</a></li>
		<li>康桥大学 Dr Markus Kuhn 的文献：<a href="http://www.cl.cam.ac.uk/~mgk25/unicode.html" target="_blank">http://www.cl.cam.ac.uk/~mgk25/unicode.html</a></li>
		<li>Debian 社区所写的文档：<a href="http://www.debian.org/doc/manuals/intro-i18n/" target="_blank">http://www.debian.org/doc/manuals/intro-i18n/</a></li>
		</ul></li>
	<li>GNU 计划的 BASH 说明：<a href="http://www.gnu.org/software/bash/manual/bash.html" target="_blank">http://www.gnu.org/software/bash/manual/bash.html</a></li>
	<li>man bash</li>
</ul>
</div>
</div>	<!-- mainarea -->
</div>  
</body></html>